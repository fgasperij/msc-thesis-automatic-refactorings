* Motivación y smells
El software evoluciona y con él todos sus componentes. Uno de ellos son los
métodos, los cuales a medida que evolucionan ganan funcionalidad y se vuelven
más complejos. Los atributos más tangibles que reflejan esa complejidad son:

- el largo del mismo medido en líneas de código o statements del lenguaje de
  programación
- la cantidad de parámetros que recibe o colaboradores externos
- la cantidad de variables temporales que define y utiliza

:REF:
Fowler y Beck
:END:
Este crecimiento hace que el método sea más grande y reduce su
:REPHRASE:
situación representa un buen candidato para aplicar un refactoring porque si no
se realiza uno se corrent los X riesgos
:END:
entendibilidad. Al encontrarse con un método con estas características el
programador aplicará un refactoring para poder reducir su complejidad y
entenderlo más fácilmente. Sin volverlo más entendible corre el riesgo de
malinterpretarlo y modificarlo erróneamente o utilizarlo erróneamente, lo cual
introduciría un bug en el programa. Además, aplicar un refactoring le permite
correr menos riesgos a él y aumenta la mantenibilidad del código lo cual implica
un gran ahorro de costos.

:REPHRASE:
y este salto? Arranqué la sección explicando una situación que suele ameritar la
utilización de un refactoring y paso a esto:
:END:
Existen dos principales razones que reducen la comprensibilidad de un método:

:WRITE:
puedo poner un ejemplo de cada una de éstas.
:END:
- tiene más de una responsabilidad
- trabaja en más de un nivel de abstracción

:WRITE:
ejemplo de extract method
:END:
La principal herramienta para reducir la complejidad producida por esas razones
es el refactoring Extract Method. En el primer caso se delega la responsabilidad
a otro método y en el segundo se realizan las tareas de un nivel de abstracción
menor al del método en otro método al que también se delega. De esta forma el
método contará con una sola responsabilidad y la cumplirá realizando acciones en
un solo nivel de abstracción. Así consigue revelar la intención del método y
solo mostrar como se consigue su objetivo delegando a otros métodos. Se agrega
un nivel de indirección por la llamada al método, la delegación, pero se gana en
claridad lo cual deja un saldo positivo para el sistema. Sin embargo, existen
casos en los que Extract Method no se puede realizar o las formas en las que se
puede realizar no consiguen un aumento de la entendibilidad del método o una
reducción de su complejidad. En estos casos Extract Method no puede aplicarse
porque:

:WRITE:
mostrar ejemplos
:END:
:WRITE:
acá me podría extender con secciones de código que expliquen los dos casos, el
pasar varios parámetros y el asignar a más de una variable.
:END:
- las variables temporales y los parámetros están tan entrelazados en el
  código que al extraer un método hay que pasarle demasiados parámetros
- cualquier sección significativa que se intenta extraer modifica más de
  una variable que luego se sigue utilizando

:REF:
Fowler + Beck
:END:
En estos casos la sugerencia es utilizar Extract Method to Method Object.

:WRITE:
por qué es sugerido? No hay explicación de cómo el ETMO supera los límites del
EM
:END:
:WRITE:
El objetivo del MO es proveer un lugar donde se pueda aplicar EM cómodamente,
estaría bueno explicar eso, el rationale de por qué supera los límites y cómo se
manifiesta
:END:


* ¿En qué consiste?

:WRITE:
Antes de describir en concreto en qué consiste paso a paso dar una breve
descripción de alto nivel. Dónde se empieza, dónde se termina y qué entidades
nuevas se crean en el medio. Un diagramita o un ejemplo en código puede que
ayuden.
:END:
Algunos detalles dependen específicamente del lenguaje de programación
utilizado, esta descripción de alto nivel asumirá un caso estándar en
Smalltalk. Los pasos a seguir para extraer el código del método M a un Method
Object son:

:WRITE:
Acá estaría bárbaro tener un diagrama con números que vayan guiando
en qué orden se van haciendo las cosas y para que haya una referencia global
de lo que se está describiendo.
:END:
1. Se crea una clase para el Method Object.
2. Se le agrega un mensaje de creación de instancia que recibe todos los
   parámetros y variables de instancia utilizadas en M y los asigna a
   variables de instancia del Method Object.
3. Se le agrega el mensaje \#value al Method Object.
4. Se copia el código de M dentro del método \#value del Method Object.
5. Se reemplazan en \#value los nombres de las variables que fueron
   pasadas por parámetro por el nombre de su variable de instancia
   correspondiente.
6. Se reemplaza el cuerpo M por la instanciación del Method Object
   pasándole todos los parámetros y variables de instancia previamente
   utilizadas.
7. Se corren los tests para verificar la preservación de comportamiento.
8. Se aplican los refactorings que antes no se podían sobre el método
   \#value del Method Object.

:REORDER:
Quizás es mejor primero mostrar un caso concreto y después como resumen
mostrar los pasos abstractos que representan todas las aplicaciones del
refactoring.
:END:
Veamos los pasos en un caso concreto:

:REPHRASE:
Usar un modelo común para los ejemplos, creo que es más fácil seguirlos.
Algo tan despegado de la realidad no creo que ayude.
:END:

:REPHRASE:
Buscar un ejemplo en cuis donde amerite la utilización del refactoring.
:END:

#+BEGIN_SRC 
ExampleClass>>methodToExtract: aParam1 with: aParam2
  | temp1 |

  temp1 := self doSomething: ivar1.

  ^(param1 + param2) > 3 and: [temp1 > 5]
#+END_SRC


~methodToExtract~ es el método objeto de nuestro refactoring. Luego de crear la
clase del Method Object le agregaremos el mensaje de creación de instancia:

#+BEGIN_SRC
MethodObject>>initializeWith: aParam1 with: aParam2 with: anIvar1 with: aSelf

  ivarParam1 := aParam1.
  ivarParam2 := aParam2.
  ivarIvar1 := anInvar1.
  client := aSelf.
#+END_SRC

Luego agregamos el mensaje ~value~ al Method Object con el contenido de
~methodToExtract~ y reemplazamos las variables recibidas como parámetro:

:WRITE:
Estaría bueno hacer una tablita o algo mostrando los cambios y quizás
aclaraciones o detalles de cada uno como cuáles son las variables a reemplazar y
por qué valor se reemplazaron.
:END:

#+BEGIN_SRC 
MethodObject>>value
  | temp1 |

  temp1 := client doSomething: ivarIvar1.

  ^(ivarParam1 + ivarParam2) > 3 and: [temp1 > 5]
#+END_SRC

finalmente reemplazamos el cuerpo del ~methodToExtract~:

#+BEGIN_SRC 
ExampleClass>>methodToExtract: aParam1 with: aParam2
  ^(MethodObject with: aParam1 with: aParam2 with: ivar1 with: self) value
#+END_SRC


* Descripción completa de la funcionalidad del refactoring implementado

:SECTION_INTENT:
Voy a contar cómo funciona el refactoring de manera top down hasta llegar al
detalle del código e incluso mostrar partes de código específicas.
:END:

El refactoring implementado tiene como objeto central al encargado de
efectivamente aplicar el refactoring, un objeto llamado
~ExtractToMethodObject~. Comenzaremos explicando en detalle el
comportamiento, las limitaciones y el funcionamiento de este objeto. Luego
pasaremos a ver cómo colabora con el resto del modelo para ofrecer al usuario
una funcionalidad completa.

A partir de ahora nos referiremos como ~ExtractToMethodObject~ al
objeto que aplica el refactoring especificando en cada caso si hablamos de la
clase o una instancia del mismo. ~ExtractToMethodObject~ es subclase
de ~Refactoring~ que tiene al mensaje ~apply~ como único
mensaje polimórfico.

#+BEGIN_SRC plantuml :file extract_to_method_object_and_refactoring_class_diagram.png
Refactoring <|-- ExtractToMethodObject

Refactoring : apply
ExtractToMethodObject : apply
#+END_SRC

#+RESULTS:
[[file:extract_to_method_object_and_refactoring_class_diagram.png]]

Veamos un ejemplo de utilización del refactoring:

#+BEGIN_SRC 
refactoring := ExtractToMethodObject
  from: methodToExtract
  toMehtodObjectClassNamed: #MethodObject
  subclassing: Object
  onCategory:'ThesisExamples'
  withExtractedVariablesToInstanceVariables: variablesNameMapping
  withInstanceCreationMessageFrom: keywordsDefinitions
  evaluatedWith: #value.

  refactoring apply.
#+END_SRC

Los colaboradores recibidos son:

- ~from~: el método sobre el cual aplicar el refactoring
- los valores necesarios para declarar el Method Object
  - ~toMethodObjectClassNamed~: el nombre que recibirá la clase del Method Object
  - ~subclassing~: la superclase del Method Object
  - ~onCategory~: la categoría en la cual declarar el Method Object
- ~withExtractedVariablesToInstanceVariables~: los nombres de las variables de instancia para las variables
  parametrizadas
- la definición del mensaje de creación de instancia ~withInstanceCreationMessageFrom~:
  - las keywords
  - los nombres de los parámetros
- ~evaluatedWith~: el nombre para el mensaje de evaluación

El mensaje de creación de instancia se encargará de validar todos los
colaboradores recibidos para asegurarse que la instancia creada será válida y
el refactoring podrá ser aplicado. Una vez instanciado el refactoring, a menos
que alguna de las condiciones validadas sea modificada en el espacio de tiempo
entre la creación de la instancia y la aplicación del refactoring, posibilidad
que siempre existe en Smalltalk por ser un entorno de objetos vivos y reflexivo,
la aplicación del refactoring no debería fallar. Es decir, si por alguna razón
el refactoring no puede ser aplicado la responsabilidad de detectarlo es de la
clase, no creará instancias que no puedan ser aplicadas ya que las
consideraremos inválidas.


* Validaciones

:WRITE:
Explicar a nivel código qué se recibe, qué es parametrizable y qué no.

A qué me refería? En la sección anterior hay una invocación, además de eso
quiero mostrar qué forma tiene cada parámetro? Creo que está más adelante.
Lo confirmo después.
:END:

El mensaje de creación de instancia tiene como primer parámetro al método cuyo
cuerpo se extraerá con el keyword ~from:~. Este método a extraer es una instancia
de ~CompiledMethod~, objeto que representa un método compilado que la
máquina virtual puede interpretar. Este objeto encapsula dos elementos
necesarios del refactoring:

- El código del método a extraer y su representación en un AST de objetos a
  través del mensaje ~methodNode~ que nos devuelve una instancia de ~MethodNode~
  correspondiente al método a extraer.
- La clase que es el contexto y para la cual está compilado el método. La misma
  se obtiene a través del mensaje ~methodClass~, que devuelve una instancia de
  ~MethodClass class~, sublcase de ~Metaclass~.

** Validaciones sobre el método a extraer

*** No puede contener referencias a la pseudovariable ~super~

No se permite realizar el refactoring sobre métodos que contienen referencias a
~super~ porque no se puede replicar el comportamiento de enviar un
mensaje a ~super~ en el Method Object sin modificar considerablemente
la clase que contiene el método a extraer, complejizándo el refactoring
demasiado para la utilización que envisionamos por ahora. El receptor de un
envío de mensaje a ~super~ es el mismo que el receptor de un envío de
mensaje a la pseudovariable ~self~, es decir, la instancia 
contexto del método que se está ejecutando. La diferencia reside en que el
method lookup inicia en la superclase del receptor, en lugar de iniciarse en su
clase. Por lo tanto, para poder replicar el mismo comportamiento los envíos a
~super~ deberían seguir realizándose desde la clase del método. Esto
se podría conseguir agregando mensajes a la clase del método que realicen los
envíos a ~super~, pero configurar la creación de estos mensajes para
que se realice automáticamente hubiera agregado más pasos a la aplicación del
refactoring y no nos pareció prudente agregarlo sin contar con evidencia de que
una versión más simple, sin esta funcionalidad, fuera aceptada y entendida con
facilidad por los usuarios. Veremos un pequeño ejemplo para ilustrar el
caso. Supongamos que el método a extraer es:

#+BEGIN_SRC 
ExampleClass>>methodToExtract
  | temp1 |

  temp1 := ivar1 + super doSomething

  ^temp 1
#+END_SRC

la forma de replicar el comportamiento sería agregar un mensaje a la clase que
realice la llamada a ~super~:

#+BEGIN_SRC 
ExampleClass>>sendDoSomethingToSuper

  ^super doSomething
#+END_SRC

y utilizar este mensaje desde el método de evaluación del Method Object:

#+BEGIN_SRC 
MehtodObjectClass>>value
  | temp1 |

  temp1 := correspondingIvar + client sendDoSomethingToSuper

  ^temp 1
#+END_SRC


*** No contiene asignaciones a variables que no sean temporales
Las variables no temporales son las variables del contexto de la clase:

- variables de instancia
- variables de clase
- variables de pool

Estas variables solo son accesibles desde el contexto de la clase, concretamente
desde dentro de un método de la clase. La única forma de asignarles un valor
desde fuera de la clase es enviándole a la clase un mensaje con el valor que
queremos asignarles y que el método lo asigne, por ejemplo:

#+BEGIN_SRC 
ExampleClass>>>setInstanceVariableTo: aValue

  instanceVariable := aValue.
#+END_SRC

Estos métodos pueden ser creados automáticamente para replicar el comportamiento
de la asignación desde el Method Object. Sin embargo, como en el caso con las
referencias a ~super~ no lo implementamos porque priorizamos mantener
la primer versión del refactoring simple ya que su principal objetivo es
exploratorio. Implementarlo hubiera requerido detectar todas las asignaciones a
este tipo de variables, ofrecerle la posibilidad al usuario de configurar cómo
serían los mensajes para asignarlas desde el Method Object y luego crearlos
automáticamente. El código para detectar las asignaciones es parte de la
validación, si en el futuro quisiera implementarse el flujo completo solo
restaría agregar la parte de configuración para la creación automática de los
métodos.


** Validaciones sobre los parámetros de la creación de la Method Object Class

Los parámetros que siguen son los de los keywords ~toMehtodObjectClassNamed:~,
que recibe el nombre de la Method Object class, ~subclassing:~, que recibe la
superclase de la Method Object class y, por último, ~onCategory:~ que recibe la
categoría en la cual se ubicará la Method Object class. Las validaciones sobre
estos elementos son las mínimas necesarias para la definición de una nueva
clase, son validaciones que también realiza Cuis cuando intentamos definir una
nueva clase manualmente. Las realizamos aquí también para poder controlar de
forma más granular el feedback que se le da al usuario y los flujos que se
siguen. También entra en esta categoría el selector de evaluación que se recibe
en el keyword ~evaluatedWith:~ ya que es un selector unario que es validado de
la misma manera que Cuis.

:REFERENCE:
Smalltalk-80 blue book - Capítulo 5
:END:

La única validación extra es realizada sobre la superclase y consiste en
verificar que no sea una metaclase, es decir, una instancia de
~Metaclass~. Sería inusual que un usuario elija una metaclase como superclase de
la Method Object class porque entonces las instancias serían clases, lo cual es
incoherente con el metamodelo de Smalltalk.  Además, las metaclases no contienen
en su protocolo el mensaje ~subclass:~ por lo cual no se puede heredar de ellas.


** Validaciones sobre las variables de instancia de la clase del Method Object

El keyword ~withExtractedVariablesToInstanceVariables:~ recibe un parámetro que
define cómo debe llamarse la variable de instancia correspondiente a cada
variable a parametrizar.

*** ¿Qué son las variables a parametrizar?

Las variables a parametrizar son todas las variables referenciadas en el
método a extraer que no son temporales:

#+BEGIN_SRC 
ExampleClass>>methodToExtract: aParam
  | aTemp |

  aTemp := self doSomethingWith: ivar1.
    
  ^aTemp
#+END_SRC

Este método referencia 4 variables que usaremos como ejemplo de las 4 categorías
de variables que podemos encontrar en un método:

- ~aParam~ :: parámetros del método.
- ~aTemp~ :: las variables temporales del método.
- ~self~ :: las pseudovariables (self y super).
- ~ivar1~ :: las variables del contexto de la clase (variables de instancia,
  variables de clase y variables de pool)

Todas las categorías de variables deben ser parametrizadas excepto las
temporales, ya que pertencen al contexto del método por lo tanto basta con
redefinirlas. En el ejemplo anterior el conjunto de variables a parametrizar, es
decir que tenemos que pasarle al Method Object al instanciarlo para que pueda
referenciarlas, son: ~aParam~, ~self~ y ~ivar1~.
 

*** Las validaciones

Las variables a parametrizar se utilizarán para la creación del Method Object y
en él serán variables de instancia, lo cual las hará disponibles desde cualquier
contexto dentro del Method Object y así se podrán aplicar refactorings más
sencillos sobre el método extraido. Los nombres son uno de los atributos que más
influyen en la entendibilidad del código y por lo tanto no deben tomarse a la
ligera. Los nombres se eligen de manera contextual, referencian a un objeto por
su rol en ese contexto específico. Al cambiar el contexto, como en este caso que
pasan de un método a la clase del Method Object, algunos nombres probablemente
deban cambiar. En algunos casos necesitan cambiar por el cambio de contexto pero
en otros también por limitaciones sintácticas como en el caso de las
pseudovariables. Si ~self~ es una variable a parametrizar la variable de
instancia correspondiente no puede llamarse también self porque es un nombre
reservado.

El objeto recibido es un diccionario que tiene como clave el nombre de la
variable a parametrizar y como valor el nombre que se le debe dar a la variable
de instancia correspondiente:

#+BEGIN_SRC 
  { 'self' -> 'client' } asDictionary.
#+END_SRC

Ese objeto representaría que la única variable a parametrizar es
~self~ y la variable de instancia correspondiente en el Method Object
debe llamarse ~client~.

Si se respetan las siguientes restricciones, que son verificadas por el mensaje
de creación de instancia del ~ExtractToMethodObject~, los nombres pueden ser
elegidos libremente:

:DIAGRAM:
Creo que acá se aclararía mucho el panorama con un buen diagrama.
Algo que muestre de manera clara los conjuntos, qué definen y las restricciones
necesarias de cada uno.
Creo que con un ejemplo guía sería más fácil aún. Algo que muestre el contenido
de cada conjunto y quizás en rojo los posibles errores de duplicado, etc.
:END:

- deben tener una consistencia interna: los nombres de las variables de
  instancia no deben repetirse y los nombres de los parámetros tampoco.
- los nombres de las variables de instancia deben ser válidos y no deben
  existir colisiones entre los nombres elegidos y:
  - las variables de instancia de su jerarquía
  - las variables de clase de su jerarquía
  - las variables de pool
  - las variables temporales del método a extraer
  - las variables temporales y los argumentos de los bloques definidos
    en el método a extraer
- todas las variables a parametrizar tienen definido un nombre
  correspondiente


** Validaciones sobre las definiciones del mensaje de creación de instancia

El mensaje de creación de instancia tiene tantos parámetros como variables a
parametrizar, por lo tanto el usuario debe definir cómo se llamará cada keyword
y el nombre del parámetro correspondiente. El objeto que se recibe en el keyword
~withInstanceCreationMessageFrom:~ es una colección ordenada de
objetos que contienen el keyword elegido, el nombre del parámetro que irá en ese
keyword y a qué variable corresponde. Veamos un ejemplo, supongamos que las
variables a parametrizar son ~iVar1~ y ~classVar1~, entonces
el mensaje de creación de instancia deberá tener 2 keywords y sus
correspondientes parámetros. El method header puede ser:

#+BEGIN_SRC 
MethodObject>>withIvar: anIvar withClassVar: aClassVar
#+END_SRC

Asumiendo que se busca que ~iVar1~ se bindee a ~anIvar~ y
~classVar1~ a ~aClassVar~ la colección para definirlo es:

#+BEGIN_SRC 
{
  {
    #keyword -> 'withIvar'.
    #variableName -> 'iVar1'.
    #parameterName -> 'anIvar'.
  } asDictionary.
  {
    #keyword -> 'withClassVar'.
    #variableName -> 'classVar1'.
    #parameterName -> 'aClassVar'.
  } asDictionary.
}
#+END_SRC

Las validaciones sobre este objeto son simples. Además de verificar que los
nombres y los keywords son válidos solo es necesario ver que los nombres de los
parámetros no estén duplicados y que cada variable a parametrizar tenga su
correspondiente definición.


* Aplicación del refactoring

Ya vimos en qué consiste el refactoring a grandes rasgos, ahora veremos los
detalles de la implementación, las decisiones que se tomaron y los mayores
desafíos que encontramos. Los 4 grandes pasos de la aplicación son:

- Creación de la Method Object class
- Generación del método de creación de instancias
- Generación del método de evaluación
- Reemplazo del método a extraer por la evaluación del Method Object

La creación de la clase del Method Object es simple en Smalltalk, las clases son
objetos por lo tanto se puede crear una nueva clase simplemente enviando un
mensaje a la superclase elegida para el Method Object.

El mensaje de creación de instancias tiene un caso en particular en el cual el
método a extraer no cuenta con variables a parametrizar. En ese caso existen dos
opciones: 1) parametrizar el selector de ese mensaje para que el usuario pueda
decidir cómo llamarlo 2) utilizar el mensaje ~new~ de
~Object~. Decidimos usar ~new~ para reducir la cantidad
configuraciones que se le piden al usuario. Entonces, si no existen variables a
parametrizar el método a extraer quedaría así:

#+BEGIN_SRC 
ExampleClass>>methodToExtract MethodObject new value
#+END_SRC

La generación del método de creación de instancias implica compilar el código
fuente del método en la clase del Methdo Object. Todas las clases responden al
mensaje ~compile~. Por lo cual para poder agregar el método a la clase
del Method Object solo necesitamos generar el código fuente correspondiente. Las
dos formas que consideramos para realizar esto es construir el texto, el
~String~, del código fuente o construir una abstracción del mismo,
representada por objetos, que luego pueda ser traducida a código fuente. La
abstracción más utilizada para representar código fuente es el AST del
mismo. Cuis tiene una jerarquía de objetos que representan los posibles nodos de
un AST pero la construcción del árbol es realizada por el ~Parser~ a
partir de un código fuente ya existente. Ese modelo del AST no incluye la
posibilidad de relizarle modificaciones al mismo para luego generar un nuevo
código fuente. Se decidió utilizar el modelo del AST para casos específicos en
los cuales se podía reutilizar alguna funcionalidad incluida en él pero para la
generación de nuevos métodos y modificaciones a códigos ya existentes se trabajó
siempre directamente con el código fuente y su representación como
~String~. Veamos un ejemplo para poder señalar algunos detalles ya que
el funcionamiento de la generación es simple:

#+BEGIN_SRC 
    { { #keyword -> 'from'.  #parameterName -> 'aSource'.  #variableName ->
        'factory'.  } asDictionary.

        { #keyword -> 'to'.  #parameterName -> 'aTarget'.  #variableName ->
          'store'.  } asDictionary.  }
#+END_SRC

La generación de la instancia tiene dos partes agrega un mensaje en la Method
Object class y un mensaje en la instancia que inicializa el objeto. Continuando
el ejemplo los mensajes quedarían como:

#+BEGIN_SRC 
MethodObject class>>from: aSource to: aTarget ^MethodObject new initializeFrom:
aSource to: aTarget
#+END_SRC

y en la instancia:

#+BEGIN_SRC 
"Asumiendo que se eligieron estos nombres para las variables de instancia."
{
    'factory' -> 'source'.  'store' -> 'target'.  }
MethdoObject>>initializeFrom: aSource to: aTarget source := aSource.  target :=
aTarget.
#+END_SRC

El mensaje en la Method Object class es un factory method que crea la nueva
instancia y la inicializa enviándole un mensaje que se llama igual que el
factory method pero prefijado con ~initialize~. El mensaje de
inicialización en la instancia le asigna a cada una de las variables de
instancia su correspondiente variable parametrizada.

La generación del método de evaluación es más compleja porque incluye el
reemplazo de todas las variables

:REFERENCE:
Agregar en el apéndice el código de
ExtractToMethodObject>>compileExtractedMethodAsEvaluationMethodOn: y agregar una referencia de esa
parte del apéndice acá.
:END:

que se parametrizaron por el nombre de la variable de instancia
correspondiente. El código específico se encuentra en el apéndice. El reemplazo
utiliza el AST del método a extraer y al ~Encoder~. Utilizaremos la
clase ~Encoder~, de la misma manera que lo hace el
~Debugger~, para obtener los rangos en el código fuente que se
corresponden con un nodo del AST. La generación del código fuente con los
reemplazos se divide en los siguientes pasos:


1. Se genera una colección ordenada de pares (rango, nombre). El rango es
   un intervalo en el código fuente que indica el rango de caracteres en el
   código fuente que debe ser reemplazado por la segunda coordenada, el
   nombre de la variable de instancia correspondiente. La generación de esta
   colección se realiza consultando al ~Encoder~ por los rangos de
   la variables a parametrizar y colocando cada rango con el nombre de su
   correspondiente variable de instancia.
2. Se realiza el reemplazo de los rangos por los nombres
   correspondientes.
3. Se reemplaza el encabezado del método original por el selector de
   evaluación elegido.
4. Se compila el código fuente generado en el Method Object.

Finalmente, el último paso es reemplazar el método a extraer por la evaluación
del Method Object.  Esta parte es parecida a la de la generación del código para
el mensaje de creación de instancia. La evaluación del Method Object se realiza
enviandole el mensaje de creación de instancia a la clase pero, en lugar de
utilizar los nombres de los parámetros se utilizan las variables a parametrizar
y se utiliza el selector de evaluación elegido para evaluarlo. Un detalle de
esta parte es qué hacer si el método a extraer no cuenta con un statement de
return, es decir el return es implícito. Los métodos que no cuentan con un
return explícito en Cuis devuelven self, el receptor del mensaje.  Decidimos
preservar el nuevo método lo más parecido al anterior y no agregar returns, por
lo tanto si contaba con un return implícito el nuevo código también utiliza un
return implícito. Solo se agrega un return a la evaluación del Method Object en
los casos en los que hay algún return explícito y el valor a devolver es
distinto de self.


* ¿Cómo se utiliza?

El modelo ~ExtractToMethodObject~ colabora con un
~RefactoringApplier~ y un ~ExtractToMethodObjectForm~ para
ofrecerle la funcionalidad al usuario y que pueda configurar el refactoring. Una
secuencia exitosa:

:DIAGRAM:
Un diagrama de secuencia que muestre como se relacionan. Lo hice en el cuaderno.
:END:

:DIAGRAM:
cómo es una secuencia exitosa
un diagrama de objetos de las tres clases relacionadas. Lo hice en el cuaderno.
:END:

en Cuis se puede ver de esta forma:

:DIAGRAM:
secuencia de screenshots que muestran cómo se aplica.
:END:

Unan secuencia con un error sigue estos pasos:

:DIAGRAM:
un diagrama de secuencia que muestre como se relacionan. Lo hice en el cuaderno.
:END:

y en Cuis el usuario lo ve así:

:DIAGRAM:
secuencia de screenshots que muestran cómo se aplica.
:END:

Vemos que en este caso si alguna validación falla el usuario puede seguir
modificando los parámetros hasta pasarla. Además, las validaciones que no
dependen del input del usuario son realizadas también antes de presentarle el
formulario al usuario, de esta forma si el método contiene una referencia a
~super~ el usuario se entera inmediatamente y no después de llenar
todos los parámetros necesarios. Al finalizar el refactoring si detectamos algo
que probablemente deba ser modificado pero no es realizado automáticamente se le
informa al usuario para que sepa las limitaciones del refactoring que aplicó.


* Preservación del comportamiento

:WRITE:
resumir cómo ganamos confianza y los tests más importantes
:END:

Aplicaré los refactorings a distintas partes de Cuis y después le voy a correr
los tests.

