\section{Motivación y smells}
El software evoluciona y con él todos sus componentes. Uno de ellos son los
métodos, los cuales a medida que pasa el tiempo van ganando funcionalidad y cada
vez se vuelven más complejos. Los atributos más tangibles que hacen crecer esa
complejidad son:

\begin{itemize}
    \item el largo medido en líneas de código o statements
    \item la cantidad de parámetros que recibe
    \item la cantidad de variables temporales que define
\end{itemize}

% REF Fowler y Beck
Este crecimiento hace que el método sea más grande y reduce su
% REPHRASE esta situación representa un buen candidato para aplicar un
% refactoring porque si no se realiza uno se corrent los X riesgos
entendibilidad. Al encontrarse con un método con estas características el
programador aplicará un refactoring para poder reducir su complejidad y
entenderlo más fácilmente. Sin volverlo más entendible corre el riesgo de
malinterpretarlo y modificarlo erróneamente o utilizarlo erróneamente, lo cual
introduciría un bug en el programa. Además, aplicar un refactoring le permite
correr menos riesgos a él y aumenta la mantenibilidad del código lo cual implica
un gran ahorro de costos.

% WTF REPHRASE y este salto? Arranqué la sección explicando una situación que suele
% ameritar la utilización de un refactoring y paso a esto:
Existen dos principales razones que reducen la comprensibilidad de un método:

% WRITE puedo poner un ejemplo de cada una de éstas.
\begin{itemize}
    \item tiene más de una responsabilidad
    \item trabaja en más de un nivel de abstracción
\end{itemize}

% WRITE ejemplo de extract method
La principal herramienta para reducir la complejidad producida por esas razones
es el refactoring Extract Method. En el primer caso se delega la responsabilidad
a otro método y en el segundo se realizan las tareas de un nivel de abstracción
menor al del método en otro método al que también se delega. De esta forma el
método contará con una sola responsabilidad y la cumplirá realizando acciones en
un solo nivel de abstracción. Así consigue revelar la intención del método y
solo mostrar como se consigue su objetivo delegando a otros métodos. Se agrega
un nivel de indirección por la llamada al método, la delegación, pero se gana en
claridad lo cual deja un saldo positivo para el sistema. Sin embargo, existen
casos en los que Extract Method no se puede realizar o las formas en las que se
puede realizar no consiguen un aumento de la entendibilidad del método o una
reducción de su complejidad. En estos casos Extract Method no puede aplicarse
porque:

% WRITE mostrar ejemplos
% WRITE acá me podría extender con secciones de código que expliquen los dos casos, el pasar varios
% parámetros y el asignar a más de una variable.
\begin{itemize}
    \item las variables temporales y los parámetros están tan entrelazados en el
      código que al extraer un método hay que pasarle demasiados parámetros
    \item cualquier sección significativa que se intenta extraer modifica más de
      una variable que luego se sigue utilizando
\end{itemize}

% REF Fowler + Beck
En estos casos la sugerencia es utilizar Extract Method to Method Object.

% WRITE por qué es sugerido? No hay explicación de cómo el ETMO supera los límites del EM
% WRITE El objetivo del MO es proveer un lugar donde se pueda aplicar EM cómodamente,
% estaría bueno explicar eso, el rationale de por qué supera los límites y cómo se
% manifiesta

\section{¿En qué consiste?}

% WRITE antes de describir en concreto en qué consiste paso a paso dar una breve
% descripción de alto nivel. Dónde se empieza, dónde se termina y qué entidades
% nuevas se crean en el medio. Un diagramita o un ejemplo en código puede
% que ayuden.
Algunos detalles dependen específicamente del lenguaje de programación
utilizado, esta descripción de alto nivel asumirá un caso estándar en
Smalltalk. Los pasos a seguir para extraer el código del método M a un Method
Object son:

% WRITE Acá estaría bárbaro tener un diagrama con números que vayan guiando
% en qué orden se van haciendo las cosas y para que haya una referencia global
% de lo que se está describiendo.
\begin{enumerate}
    \item Se crea una clase para el Method Object.
    \item Se le agrega un mensaje de creación de instancia que recibe todos los
      parámetros y variables de instancia utilizadas en M y los asigna a
      variables de instancia del Method Object.
    \item Se le agrega el mensaje \#value al Method Object.
    \item Se copia el código de M dentro del método \#value del Method Object.
    \item Se reemplazan en \#value los nombres de las variables que fueron
      pasadas por parámetro por el nombre de su variable de instancia
      correspondiente.
    \item Se reemplaza el cuerpo M por la instanciación del Method Object
      pasándole todos los parámetros y variables de instancia previamente
      utilizadas.
    \item Se corren los tests para verificar la preservación de comportamiento.
    \item Se aplican los refactorings que antes no se podían sobre el método
      \#value del Method Object.
\end{enumerate}

% REORDER quizás es mejor primero mostrar un caso concreto y después como resumen
% mostrar los pasos abstractos que representan todas las aplicaciones del
% refactoring
Veamos los pasos en un caso concreto:

\begin{code}
ExampleClass>>methodToExtract: aParam1 with: aParam2 | temp1 |

    temp1 := self doSomething: ivar1.

    ^(param1 + param2) > 3 and: [temp1 > 5]
\end{code}

\lstinline{methodToExtract} es el método objeto de nuestro refactoring. Luego de
crear la clase del Method Object le agregaremos el mensaje de creación de
instancia:

\begin{code}
MethodObject>>initializeWith: aParam1 with: aParam2 with: anIvar1 with: aSelf
ivarParam1 := aParam1.  ivarParam2 := aParam2.  ivarIvar1 := anIvar1.  client :=
aSelf.
\end{code}

Luego agregamos el mensaje \lstinline{value} al Method Object con el contenido
de \lstinline{methodToExtract} y reemplazamos las variables recibidas como
parámetro:

\begin{code}
MethodObject>>value | temp1 |

    temp1 := client doSomething: ivarIvar1.

    ^(ivarParam1 + ivarParam2) > 3 and: [temp1 > 5]
\end{code}

finalmente reemplazamos el cuerpo del \lstinline{methodToExtract}:

\begin{code}
ExampleClass>>methodToExtract: aParam1 with: aParam2 ^(MethodObject with:
aParam1 with: aParam2 with: ivar1 with: self) value
\end{code}



\section{Descripción completa de la funcionalidad del refactoring implementado del modelo}

% WRITE voy a contar cómo funciona el refactoring de manera top down hasta llegar al detalle del código
% e incluso mostrar partes de código específicas. Todo lo que necesite contar en el camino lo contaré.
% No voy a desarrollar todo, solo lo que crea necesario y dejo señalados los lugares en los que se puede 
% expandir la explicación.

El refactoring implementado tiene como objeto central al encargado de
efectivamente aplicar el refactoring, un objeto llamado
\lstinline{ExtractToMethodObject}. Comenzaremos explicando en detalle el
comportamiento, las limitaciones y el funcionamiento de este objeto. Luego
pasaremos a ver cómo colabora con el resto del modelo para ofrecer al usuarion
una funcionalidad completa.

A partir de ahora nos referiremos como \lstinline{ExtractToMethodObject} al
objeto que aplica el refactoring especificando en cada caso si hablamos de la
clase o una instancia del mismo. \lstinline{ExtractToMethodObject} es subclase
de \lstinline{Refactoring} que tiene al mensaje \lstinline{apply} como único
mensaje polimórfico.
% DIAGRAM mostrar un diagrama de clases con refactoring, etmo y el apply
Veamos un ejemplo de utilización del refactoring:

\begin{code}
refactoring := ExtractToMethodObject from: methodToExtract
toMehtodObjectClassNamed: #MethodObject subclassing: Object onCategory:
'ThesisExamples' withExtractedVariablesToInstanceVariables: variablesNameMapping
withInstanceCreationMessageFrom: keywordsDefinitions evaluatedWith: #value.

refactoring apply.
\end{code}

Los colaboradores recibidos son:

\begin{itemize}
    \item el método sobre el cual aplicar el refactoring
    \item los valores necesarios para declarar el Method Object
    \begin{itemize}
        \item el nombre que recibirá la clase del Method Object
        \item la superclase del Method Object
        \item la categoría en la cual declarar el Method Object
    \end{itemize}
    \item los nombres de las variables de instancia para las variables
      parametrizadas
    \item la definición del mensaje de creación de instancia
    \begin{itemize}
        \item las keywords
        \item los nombres de los parámetros
    \end{itemize}
    \item el nombre para el mensaje de evaluación
\end{itemize}

El mensaje de creación de instancia se encargará de validar todos los
colaboradores recibidos para asegurarse de que la instancia creada será válida y
el refactoring podrá ser aplicado. Una vez instanciado el refactoring, a menos
que alguna de las condiciones validadas sea modificada en el espacio de tiempo
entre la creación de la instancia y la aplicación del refactoring, posibilidad
que siempre existe en Smalltalk por ser un entorno de objetos vivos y reflexivo,
la aplicación del refactoring no debería fallar. Es decir, si por alguna razón
el refactoring no puede ser aplicado la responsabilidad de detectarlo es de la
clase, no creará instancias que no puedan ser aplicadas ya que las
consideraremos inválidas.

\section{Validaciones}
% WRITE explicar a nivel código que se recibe, qué es parametrizable y qué no
El mensaje de creación de instancia tiene como primer parámetro al método a
extraer con el keyword \lstinline{from:}. Este método a extraer es una instancia
de \lstinline{CompiledMethod}, objeto que representa un método compilado que la
máquina virtual puede interpretar. Este objeto encapsula dos elementos
necesarios del refactoring:

\begin{itemize}
    \item el código del método a extraer y su representación en un AST de
      objetos a través del mensaje \lstinline{methodNode} que nos devuelve una
      instancia de \lstinline{MethodNode} correspondiente al método a extraer.
    \item la clase que es el contexto y para la cual está compilado el método
      accesible a través del mensaje \lstinline{methodClass}, que devuelve una
      instancia de \lstinline{MethodClass class} que es una sublcase de
      \lstinline{Metaclass}.
\end{itemize}

\subsection*{Validaciones sobre el método a extraer}

\subsubsection*{No puede contener referencias a la pseudovariable \lstinline{super}}

No se permite realizar el refactoring sobre métodos que contienen referencias a
\lstinline{super} porque no se puede replicar el comportamiento de enviar un
mensaje a \lstinline{super} en el Method Object sin modificar considerablemente
la clase que contiene el método a extraer, complejizándo el refactoring
demasiado para la utilización que envisionamos por ahora. El receptor de un
envío de mensaje a \lstinline{super} es el mismo que el receptor de un envío de
mensaje a la pseudovariable \lstinline{self}, es decir, la instancia que es el
contexto del método que se está ejecutando. La diferencia reside en que el
method lookup inicia en la superclase del receptor, en lugar de iniciarse en su
clase. Por lo tanto, para poder replicar el mismo comportamiento los envíos a
\lstinline{super} deberían seguir realizándose desde la clase del método. Esto
se podría conseguir agregando mensajes a la clase del método que realicen los
envíos a \lstinline{super} pero configurar la creación de estos mensajes para
que se realice automáticamente hubiera agregado más pasos a la aplicación del
refactoring y no nos pareció prudente agregarlo sin contar con evidencia de que
una versión más simple, sin esta funcionalidad, fuera aceptada y entendida con
facilidad por los usuarios. Veremos un pequeño ejemplo para ilustrar el
caso. Supongamos que el método a extraer es:

\begin{code}
ExampleClass>>methodToExtract | temp1 |

    temp1 := ivar1 + super value

    ^temp 1
\end{code}

la forma de replicar el comportamiento sería agregar un mensaje a la clase que
realice la llamada a super:

\begin{code}
ExampleClass>>sendToSuper

    ^super value
\end{code}

y utilizar este mensaje desde el método de evaluación del Method Object:

\begin{code}
MehtodObjectClass>>value | temp1 |

    temp1 := correspondingIvar + client sendToSuper

    ^temp 1
\end{code}


\subsubsection*{No contiene asignaciones a variables que no sean temporales}

Las variables no temporales son las variables del contexto de la clase:

\begin{itemize}
    \item variables de instancia
    \item variables de clase
    \item variables de pool
\end{itemize}

Estas variables solo son accesibles desde el contexto de la clase, concretamente
desde dentro de un método de la clase. La única forma de asignarles un valor
desde fuera de la clase es enviándole a la clase un mensaje con el valor que
queremos asignarles y el método lo asigna, por ejemplo:

\begin{code}
ExampleClass>>>setInstanceVariableTo: aValue

    instanceVariable := aValue.
\end{code}

Estos métodos pueden ser creados automáticamente para replicar el comportamiento
de la asignación desde el Method Object. Sin embargo, como en el caso con las
referencias a \lstinline{super} no lo implementamos porque priorizamos mantener
la primer versión del refactoring simple ya que su principal objetivo es
exploratorio. Implementarlo hubiera requerido detectar todas las asignaciones a
este tipo de variables, ofrecerle la posibilidad al usuario de configurar cómo
serán los mensajes para asignarlas desde el Method Object y luego crearlos
automáticamente. El código para detectar las asignaciones es parte de la
validación, si en el futuro quisiera implementarse el flujo completo solo
restaría agregar la parte de configuración para la creación automática de los
métodos.



\subsection*{Validaciones sobre los parámetros de la creación de la Method Object Class}

Los siguientes parámetros son los de los keywords
\lstinline{toMehtodObjectClassNamed:} que recibe el nombre de la Method Object
class, \lstinline{subclassing:} que recibe la superclase de la Method Object
class y, por último, \lstinline{onCategory:} que recibe la categoría en la cual
se ubicará la Method Object class. Las validaciones sobre estos elementos son
las mínimas necesarias para la definición de una nueva clase, son validaciones
que también realiza Cuis cuando intentamos definir una nueva clase
manualmente. Las agregamos aquí también para poder controlar de forma más
granular el feedback que se le da al usuario y los flujos que se siguen. También
entra en esta categoría el selector de evaluación que se recibe en el keyword
\lstinline{evaluatedWith:} ya que es un selector unario que es validado de la
misma manera que Cuis.
% WRITE cuando Wilki me responda agregar por qué no puede ser una metaclase
La única validación extra es realizada sobre la superclase, consiste en
verificar que no sea una Meta Clase.



\subsection*{Validaciones sobre las variables de instancia de la clase del Method Object}

El keyword \lstinline{withExtractedVariablesToInstanceVariables:} recibe un
parámetro que define cómo debe llamarse la variable de instancia correspondiente
a cada variable a parametrizar.

\subsubsection*{¿Qué son las variables a parametrizar?}
Las variables a parametrizar son todas aquellas variables referenciadas en el
método a extraer que no son temporales:

\begin{code}
ExampleClass>>methodToExtract: aParam | aTemp |

    aTemp := self doSomethingWith: ivar1.
    
    ^aTemp
\end{code}

Este método referencia 4 variables que usaremos como ejemplo de las 4 categorías
de variables que podemos encontrar en un método:

\begin{itemize}
    \item aParam: parámetros del método.
    \item aTemp: las variables temporales del método.
    \item self: las pseudovariables (self y super).
    \item ivar1: las variables del contexto de la clase (variables de instancia,
      variables de clase y variables de pool)
\end{itemize}

Todas las categorías de variables deben ser parametrizadas excepto las
temporales, ya que pertencen al contexto del método. En el ejemplo anterior el
conjunto de variables a parametrizar, es decir que tenemos que pasarle al Method
Object al instanciarlo para que pueda referenciarlas, son: \lstinline{aParam},
\lstinline{self} y \lstinline{ivar1}.

\subsubsection{Continuo hablando sobre las validaciones}

Las variables a parametrizar serán variables de instancia del Method Object, lo
cual las hará disponibles desde cualquier contexto dentro del Method Object y
así se podrá descomponer de manera simple el método extraido. Los nombres son
uno de los atributos que más influyen en la entendibilidad del código y por lo
tanto no deben tomarse a la ligera. Los nombres se eligen de manera contextual,
referencian a un objeto por su rol en ese contexto específico. Al cambiar el
contexto, como en este caso que pasan de un método a la clase del Method Object,
algunos nombres deben cambiar. En algunos casos necesitan cambiar por el cambio
de contexto pero en otros también por limitaciones sintácticas como en el caso
de las pseudovariables. Si \lstinline{self} es una variable a parametrizar la
variable de instancia correspondiente no puede llamarse también self porque es
un nombre reservado.

El objeto recibido es un diccionario que tiene como clave el nombre de la
variable a parametrizar y como valor de destino el nombre que se le debe dar a
la variable de instancia correspondiente:

\begin{code}
    { 'self' -> 'client' } asDictionary.
\end{code}

Ese objeto representaría que la única variable a parametrizar es
\lstinline{self} y la variable de instancia correspondiente en el Method Object
debe llamarse \lstinline{client}.

Si se repestan las siguientes restricciones que son verificadas los nombres
pueden ser elegidos libremente:

\begin{itemize}
    \item debe tener una consistencia interna: los nombres de las variables de
      instancia no deben repetirse y los nombres de los parámetros tampoco.
    \item los nombres de las variables de instancia deben ser válidos y no deben
      existir colisiones entre los nombres elegidos y:
    \begin{itemize}
        \item las variables de instancia de su jerarquía
        \item las variables de clase de su jerarquía
        \item las variables de pool
        \item las variables temporales del método a extraer
        \item las variables temporales y los argumentos de los bloques definidos
          en el método a extraer
    \end{itemize}
    \item todas las variables a parametrizar tienen definido un nombre
      correspondiente
\end{itemize}




\subsection*{Validaciones sobre las definiciones del mensaje de creación de instancia}

El mensaje de creación de instancia tiene tantos parámetros como variables a
parametrizar, por lo tanto el usuario debe definir cómo se llamará cada keyword
y el nombre del parámetro correspondiente. El objeto que se recibe en el keyword
\lstinline{withInstanceCreationMessageFrom:} es una colección ordenada de
objetos que contienen el keyword elegido, el nombre del parámetro que irá en ese
keyword y a qué variable corresponde. Veamos un ejemplo, supongamos que las
variables a parametrizar son \lstinline{iVar1} y \lstinline{classVar1}, entonces
el mensaje de creación de instancia deberá tener 2 keywords y sus
correspondientes parámetros. El method header puede ser:

\begin{code}
MethodObject>>withIvar: anIvar withClassVar: aClassVar
\end{code}

Asumiendo que se busca que \lstinline{iVar1} se bindee a \lstinline{anIvar} y
\lstinline{classVar1} a \lstinline{aClassVar} la colección para definirlo es:

\begin{code}
    { { #keyword -> 'withIvar'.  #variableName -> 'iVar1'.  #parameterName ->
        'anIvar'.  } asDictionary.

        { #keyword -> 'withClassVar'.  #variableName -> 'classVar1'.
          #parameterName -> 'aClassVar'.  } asDictionary.  }
\end{code}

Las validaciones sobre este objeto son simples. Además de verificar que los
nombres y los keywords son válidos solo es necesario ver que los nombres de los
parámetros no estén duplicados y que cada variable a parametrizar tenga su
correspondiente definición.


\section{Aplicación del refactoring}

Ya vimos en qué consiste el refactoring a grandes rasgos, ahora veremos los
detalles de la implementación, las decisiones que se tomaron y los mayores
desafíos que encontramos. Los 4 grandes pasos de la aplicación son:

\begin{itemize}
    \item Creación de la Method Object class
    \item Generación del método de creación de instancias
    \item Generación del método de evaluación
    \item Reemplazo del método a extraer por la evaluación del Method Object
\end{itemize}

La creación de la clase del Method Object es simple en Smalltalk, las clases son
objetos por lo tanto se puede crear una nueva clase simplemente enviando un
mensaje a la superclase elegida para el Method Object.

El mensaje de creación de instancias tiene un caso en particular en el cual el
método a extraer no cuenta con variables a parametrizar. En ese caso existen dos
opciones: 1) parametrizar el selector de ese mensaje para que el usuario pueda
decidir cómo llamarlo 2) utilizar el mensaje \lstinline{new} de
\lstinline{Object}. Decidimos usar \lstinline{new} para reducir la cantidad
configuraciones que se le piden al usuario. Entonces, si no existen variables a
parametrizar el método a extraer quedaría así:

\begin{code}
ExampleClass>>methodToExtract MethodObject new value
\end{code}

La generación del método de creación de instancias implica compilar el código
fuente del método en la clase del Methdo Object. Todas las clases responden al
mensaje \lstinline{compile}. Por lo cual para poder agregar el método a la clase
del Method Object solo necesitamos generar el código fuente correspondiente. Las
dos formas que consideramos para realizar esto es construir el texto, el
\lstinline{String}, del código fuente o construir una abstracción del mismo,
representada por objetos, que luego pueda ser traducida a código fuente. La
abstracción más utilizada para representar código fuente es el AST del
mismo. Cuis tiene una jerarquía de objetos que representan los posibles nodos de
un AST pero la construcción del árbol es realizada por el \lstinline{Parser} a
partir de un código fuente ya existente. Ese modelo del AST no incluye la
posibilidad de relizarle modificaciones al mismo para luego generar un nuevo
código fuente. Se decidió utilizar el modelo del AST para casos específicos en
los cuales se podía reutilizar alguna funcionalidad incluida en él pero para la
generación de nuevos métodos y modificaciones a códigos ya existentes se trabajó
siempre directamente con el código fuente y su representación como
\lstinline{String}. Veamos un ejemplo para poder señalar algunos detalles ya que
el funcionamiento de la generación es simple:

\begin{code}
    { { #keyword -> 'from'.  #parameterName -> 'aSource'.  #variableName ->
        'factory'.  } asDictionary.

        { #keyword -> 'to'.  #parameterName -> 'aTarget'.  #variableName ->
          'store'.  } asDictionary.  }
\end{code}

La generación de la instancia tiene dos partes agrega un mensaje en la Method
Object class y un mensaje en la instancia que inicializa el objeto. Continuando
el ejemplo los mensajes quedarían como:

\begin{code}
MethodObject class>>from: aSource to: aTarget ^MethodObject new initializeFrom:
aSource to: aTarget
\end{code}

y en la instancia:

\begin{code}
"Asumiendo que se eligieron estos nombres para las variables de instancia."  {
    'factory' -> 'source'.  'store' -> 'target'.  }

MethdoObject>>initializeFrom: aSource to: aTarget source := aSource.  target :=
aTarget.
\end{code}

El mensaje en la Method Object class es un factory method que crea la nueva
instancia y la inicializa enviándole un mensaje que se llama igual que el
factory method pero prefijado con \lstinline{initialize}. El mensaje de
inicialización en la instancia le asigna a cada una de las variables de
instancia su correspondiente variable parametrizada.

La generación del método de evaluación es más compleja porque incluye el
reemplazo de todas las variables
% REF agregar en el apéndice el código de
% ExtractToMethodObject>>compileExtractedMethodAsEvaluationMethodOn: y agregar una referencia de esa
% parte del apéndice acá.
que se parametrizaron por el nombre de la variable de instancia
correspondiente. El código específico se encuentra en el apéndice. El reemplazo
utiliza el AST del método a extraer y al \lstinline{Encoder}. Utilizaremos la
clase \lstinline{Encoder}, de la misma manera que lo hace el
\lstinline{Debugger}, para obtener los rangos en el código fuente que se
corresponden con un nodo del AST. La generación del código fuente con los
reemplazos se divide en los siguientes pasos:

\begin{enumerate}
    \item Se genera una colección ordenada de pares (rango, nombre). El rango es
      un intervalo en el código fuente que indica el rango de caracteres en el
      código fuente que debe ser reemplazado por la segunda coordenada, el
      nombre de la variable de instancia correspondiente. La generación de esta
      colección se realiza consultando al \lstinline{Encoder} por los rangos de
      la variables a parametrizar y colocando cada rango con el nombre de su
      correspondiente variable de instancia.
    \item Se realiza el reemplazo de los rangos por los nombres
      correspondientes.
    \item Se reemplaza el encabezado del método original por el selector de
      evaluación elegido.
    \item Se compila el código fuente generado en el Method Object.
\end{enumerate}

Finalmente, el último paso es reemplazar el método a extraer por la evaluación
del Method Object.  Esta parte es parecida a la de la generación del código para
el mensaje de creación de instancia. La evaluación del Method Object se realiza
enviandole el mensaje de creación de instancia a la clase pero, en lugar de
utilizar los nombres de los parámetros se utilizan las variables a parametrizar
y se utiliza el selector de evaluación elegido para evaluarlo. Un detalle de
esta parte es qué hacer si el método a extraer no cuenta con un statement de
return, es decir el return es implícito. Los métodos que no cuentan con un
return explícito en Cuis devuelven self, el receptor del mensaje.  Decidimos
preservar el nuevo método lo más parecido al anterior y no agregar returns, por
lo tanto si contaba con un return implícito el nuevo código también utiliza un
return implícito. Solo se agrega un return a la evaluación del Method Object en
los casos en los que hay algún return explícito y el valor a devolver es
distinto de self.



\section{¿Cómo se utiliza?}

El modelo \lstinline{ExtractToMethodObject} colabora con un
\lstinline{RefactoringApplier} y un \lstinline{ExtractToMethodObjectForm} para
ofrecerle la funcionalidad al usuario y que pueda configurar el refactoring. Una
secuencia exitosa:
% DIAGRAM un diagrama de secuencia que muestre como se relacionan. Lo hice en el cuaderno.
% cómo es una secuencia exitosa
% DIAGRAM un diagrama de objetos de las tres clases relacionadas. Lo hice en el cuaderno.

en Cuis se puede ver de esta forma:

% DIAGRAM secuencia de screenshots que muestran cómo se aplica.

Unan secuencia con un error sigue estos pasos:

% DIAGRAM un diagrama de secuencia que muestre como se relacionan. Lo hice en el cuaderno.

y en Cuis el usuario lo ve así:

% DIAGRAM secuencia de screenshots que muestran cómo se aplica.

Vemos que en este caso si alguna validación falla el usuario puede seguir
modificando los parámetros hasta pasarla. Además, las validaciones que no
dependen del input del usuario son realizadas también antes de presentarle el
formulario al usuario, de esta forma si el método contiene una referencia a
\lstinline{super} el usuario se entera inmediatamente y no después de llenar
todos los parámetros necesarios. Al finalizar el refactoring si detectamos algo
que probablemente deba ser modificado pero no es realizado automáticamente se le
informa al usuario para que sepa las limitaciones del refactoring que aplicó.


\section{Preservación del comportamiento}
% WRITE resumir cómo ganamos confianza y los tests más importantes
Aplicaré los refactorings a distintas partes de Cuis y después le voy a correr
los tests.
