\section{Justificación}

\subsection{¿Por qué refactorings automáticos de alto nivel?}
% Preguntas guía
%   - Cuál es el potencial de los refactorings automáticos de alto nivel
%   - Por qué creemos que son una buena herramienta
Los refactorings son una herramienta esencial del arsenal de los ingenieros de software para
minimzar el incremento de la complejidad que conlleva la evolución del software. Su uso les permite
conservar la mantenibilidad de los sistemas. La mantenibilidad, como ya vimos, es un atributo
esencial para que las aplicaciones puedan seguir aportando valor de negocio a lo largo del tiempo,
esto se consigue manteniendo los costos bajos y los tiempos de desarrollo competitivos para el
mercado.
Sin embargo, sus beneficios traen consigo riesgos y costos:

\begin{itemize}
    \item introducir bugs
    \item tiempo de desarrollo
    \item reducir la calidad del sistema
\end{itemize}

Los refactorings automáticos permiten reducir el riesgo de introducir bugs porque al estar
automatizados el espacio para error es menor, los humanos cometen más errores en operaciones que
requieren detalle y no olvidarse de nada, son programas que pueden estar testeados por más usuarios,
no se cansan y si se les encuentra algún error se puede arreglar y contar con ese arreglo en el
futuro, un programador puede cometer el mismo error un sin número de veces. El tiempo de desarrollo
se vería disminuido porque una herramienta automática es más veloz que un humano, si esto no fuera
así la herramienta es inútil. Esto sería una gran ganancia ya que el mantenimiento de un sistema es
su costo más grande, si este costo se disminuye se abarataría el costo de producir software, lo cual
con la omnipresencia actual del software tendría un impacto enorme. Al no contar con métricas
definitivas para evaluar la calidad de un sistema no es simple ver si efectivamente los refactorings
automáticos mitigarían el riesgo de bajar la calidad del sistema.
% REF al que deçía que con refactorings de patrones iban a poder probar más diseños
UNA REF postula que si los desarrolladores contaran con buenas herramientas automáticas para
realizar refactorings de alto nivel probarían más opciones de diseño, lo cual les permitiría llegar
a mejores diseños. No es concluyente pero si ciertas herramientas aportan a que los desarrolladores
lleguen a mejores diseños tienen una buena chance de aumentar la calidad de los sistemas.
Los refactorings automáticos de alto nivel cuentan con el potencial de maximizar estos beneficios
porque el scope de automatización sería mayor, lo cual implica más ahorro de tiempo de desarrollo y
menos posibilidad de introducir bugs porque existe más area del refactorings cubiera, y porque al
operar a un nivel de abstracción mayor, más cercano al nivel de la semántica del pensamiento del
programador, aumentaría la velocidad a la que podría probar diseños alternativos y así llegar a uno
mejor.

% Por qué refactorings automáticos de alto nivel
% REF hay un empirical study de esto
La referencia concluyó que los refactorings de alto nivel son más escalables y performantes.
Los refactorings automáticos aumentan la velocidad de desarrollo, resultando en una reducción de
costos y un aumento de la calidad del software porque los desarrolladores tienen la posibilidad de
probar más cambios con menos esfuerzo.

% Los dos objetivos contrapuestos de los refactorings
% REF (Refactoring Object-Oriented Frameworks)
(Refactoring Object-Oriented Frameworks) expone dos objetivos de los refactorings automáticos que se
contraponen. Un objetivo es que el refactoring sea expresivo, que su nivel sea lo más alto posible
para mantener al usuario lo más lejos posible de toda la complejidad que implica realizar el cambio,
y el otro es que preserve el comportamiento. Cuanto más alto es su nivel más difícil es justificar que
preservan el comportamiento del programa, por lo tanto queremos que los refactorings sean
suficientemente pequeños para poder tener una buena confianza de que preservan el comportamiento y
suficientemente abstractos para que sean útiles.  

% Preguntas que se hace este trabajo, por qué es exploratorio
Queremos analizar si estos refactorings serían útiles y si contribuyen a la productividad de los
programadores. Además, queremos analizar la definición de este tipo de refactorings, si se pueden
precisar sus puntos de partida o si el hecho de que sean tan abstractos los vuelve demasiado
específicos y ya no cubren una buena superficie de situaciones como para tener un impacto
significativo. Buscamos entender cuáles son los tradeoffs que presentan este tipo de refactorings,
qué dificultad tiene comunicarle al usuario la acción que está realizando y los alcances de la
misma, qué tradeoff hay entre configurabilidad y automatización.


\subsection{Relación con las investigaciones más cercanas}
% WRITE explicar cuáles son los trabajos más parecidos que encontramos y las diferencias que tienen
% con este
El trabajo más parecido es el Factory Method porque parece ser que sería útil para floss refactoring
pero no queda claro si hicieron un frontend o no. La mayoría se orienta hacia el lado de
automatización de la detección y la transformación sin consultar al usuario. El problema que vemos
con eso es que no ayuda al programador actualmente, es una propuesta de desarrollo de software
distinta a la actual. Este trabajo intenta mejorar la forma de desarrollo contemporánea.
No hay laburo de este estilo en Smalltalk.

% Por qué en Smalltalk
Un lenguaje dinámico y puro permitirá iterar más rápidamente por lo tanto es una herramienta ideal
para el prototipado y la naturaleza exploratoria de este trabajo.

\section{Valor de realizar este trabajo}
% Qué haremos y para qué
Implementaremos refactorings automáticos de alto nivel como parte de un análisis de las limitaciones
de los mismo y para poder obtener más información en el futuro acerca de su uso y efectividad.

% Por qué es necesario realizar una exploración de refactorings automáticos de alto nivel?
Se necesitan implementaciones de refactorings de este tipo para poder evaluar sus
potenciales beneficios y analizar el uso y sus limitaciones para construir alternativas
superadoras en caso de que las conclusiones extraídas sean negativas para ellos.

% Por qué es útil contar con una solución al problema?
\begin{itemize}
    \item tendremos una herramienta que permitirá medir y evaluar si se utilizan y cómo se utilizan
    estos refactorings de alto nivel en el futuro
    \item sabremos cuáles son los desafíos a la hora de definir refactorings de tan alto nivel, si
    son viables o no
    \item Chequear precondiciones y postcondiciones de refactorings es más costos y complicado. Si
    esto funciona tendríamos una opción más eficiente.
    % Algo sobre que no es fácil identificar refactorings intermedios para componerlos y hacer retrofitting de un patrón
    % WRITE había un paper que propone exactamente esto, el de compositional paradigm, revisar y ponerlo
    % para que no parezca que lo olvido.
    \item No está claro como identificar refactorings intermedios que sean útiles y que su
    composición produzca el retrofitting de un patrón.
    % REF (A Refactoring Tool for Smalltalk)
    En (A Refactoring Tool for Smalltalk) se pueden ver ejemplos en los de retrofitting the patrones
    de diseño en los que la cantidad de cambios es grandes y no es fácil identificar refactorings de
    tamaño intermedio que permitan simplificar el cambio.
\end{itemize}

El principal problema que vemos con los refactorings que no requieren intervención del programador y
no se ajustan a su forma de trabajo es que corren dos riesgos grandes:

\begin{itemize}
    \item baja frecuencia de uso: nadie los usaría ya que asumen que son parte de una etapa del
    desarrollo que no existe.
    \item incrementar los costos de un proyecto: en primer lugar, en términos de tiempo de
    desarrollo. El problema es que si el refactoring toma decisiones buenas pero que perjudican la
    mantenibilidad del código por hacerlo más complejo o menos entendible, como luego el proyecto lo
    tienen que seguir interviniendo programadores humanos cada vez les tomará más tiempo realizarle
    modificaciones.
\end{itemize}

Mientras no haya una manera precisa de expresar comprensibilidad y diseño del dominio entonces la
intervención humana es necesaria y proveerá una reducción de costos mayor que la utilización de
% REF la survey que decía que el 80% del costo del software es mantenimiento
refactorings completamente automáticos. Aportar en esta dirección aporta valor porque el
mantenimiento del software es su mayor costo.

Las IDEs más utilizadas y poderosas no proveen actualmente refactorings automáticos de este tipo,
los disponibles son más simples.

% MOVE Contribuciones del trabajo
El trabajo que se realiza también contribuye a la identificaciónd de smells porque tiene que
encontrar todos los casos en los que se produce una asignación a null