\section{Motivación y smells}

Existen pocos lenguajes de programación orientados a objetos, y de uso extendido ninguno, que no
cuenten con una u otra forma de representar el valor especial null. La utilización de null conlleva
como principal riesgo el enviarle un mensaje o derefenciarlo, dependiendo el lenguaje utilizado, lo
cual resulta en un error en runtime o una terminación abnormal del programa. La forma más simple de
prevenir estos errores es realizar chequeos sobre las variables que se sospecha pueden contener null
para evitar enviarles mensajes. Veamos un ejemplo en la clase \lstinline{Behavior} de Cuis:

\begin{code}
Behavior>>allSuperclasses
	"Answer an OrderedCollection of the receiver's and the receiver's  
	ancestor's superclasses. The first element is the receiver's immediate  
	superclass, followed by its superclass; the last element is Object."
	| temp |
	^ superclass
		ifNil: [OrderedCollection new]
		ifNotNil: [temp := superclass allSuperclasses.
			temp addFirst: superclass.
            temp]
\end{code}

En este caso se verifica si la variable de instancia \lstinline{superclass} es nil para evitar
enviarle el mensaje \lstinline{allSuperclasses} y además por que la ausencia de superclase indica
que estamos en la raíz de la jerarquía.
% REF a Fowler
Si null conlleva tantos riesgos, ¿por qué se utiliza con tanta frecuencia? La utilización de null
puede ser la forma más simple y barata de implementar un modelo en determinado estadío o caso. Sin
embargo, si los chequeos por null abundan las causas más comunes son:

\begin{itemize}
    \item que la variable de instancia sea lo que se llama un temporary field, un colaborador que no
    forma parte de la esencia del objeto y por lo tanto no es necesario siempre, entonces en algunos casos
    es null.
    \item que falte una abstracción en el modelo para representar la ausencia de un tipo de objetos.
\end{itemize}

% REF a fowler y a woolf
Fowler y Woolf describen que la motivación para realizar el refactoring son repetidos chequeos por
null de un colaborador. Los condicionales reducen la entendibilidad del código y al chequear siempre
la misma condición producen código repetido, lo cual suele aumentar la posibilidad de que el
programador introduzca bugs olvidándose de chequear por null antes de enviarle un mensaje al
colaborador correspondiente. Una de las principales herramientas del paradigma de objetos para
lidiar con la proliferación de condicionales repetidos en el código es la utilización de
polimorfismo. En lugar de chequear manualmente en qué tipo de situación nos encontramos para decidir
qué hacer, se envía un mensaje polimórfico a un objeto que realizará la tarea correspondiente para
esa situación dependiendo en su tipo. La introducción de un Null Object sigue esta guía. Se
reemplazará la utilización de null por un Null Object, un objeto que representa la ausencia o la
nada del tipo correspondiente y encapsula el comportamiento necesario en las situaciones en las
cuales hay una ausencia de ese tipo. Al contar con un Null Object ya no es necesario verificar si el
objeto es null, nunca debería ser null, y se le puede enviar los mismos mensajes que a un Concrete
Object, ya que son polimórficos, contando con que el Null Object sabrá qué hacer. Además de reducir 
la complejidad del código la introducción del Null Object consigue que las extensiones futuras sean
más seguras, ya que no hay que chequear por null, y más mantenibles porque si se requiere cierto
comportamiento adicional en un caso en el que el colaborador está ausente el cambio quedará
encapsulado en la clase del Null Object.


% En el paper de null object hay una buena introducción, si estoy falto de ideas puedo sacar de ahí.


\section{¿En qué consiste?}

La esencia del refactoring es el reemplazo de condicionales que chequean si una variable es null
o no por el envío de un mensaje polimórfico. Conseguir ese objetivo requiere de varios pasos que tienen
varias alternativas de implementación:

\begin{enumerate}
    \item Crear una jerarquía para el Null Object.
    \item Reemplazar las asignaciones de null por asignaciones del Null Object.
    \item Reemplazar los condicionales que chequean null por envíos polimórficos al objeto.
    \item Mover el comportamiento requerido para los casos en los que el objeto es null al Null
    Object.
\end{enumerate}

Llamaremos NullComponent a la clase del Null Object y Component a la clase del objeto que representa
un componente que no es null. El NullComponent será polimórfico con el Component pero no contiene
estado porque sus métodos no tienen comportamiento, están vacíos, o devuelven alguna constante, en
ocasiones en forma de un Null Object de otro tipo. En un lenguaje dinámico como Smalltalk no es
necesario que exista una relación de herencia entre las clases para que puedan utilizarse
indistintamente como en el caso de lenguajes estáticamente tipados. De todas formas se elige
utilizar una relación de herencia y relacionar al Component y al NullComponent en una misma
jerarquía para dejar la relación entre los dos explícita. La jerarquía que los relaciona puede tomar
varias formas:

% DIAGRAM acá voy a meter el mismo diagrama que está en el paper de NullObject en el que muestran que
% las distintas formas de hacer la jerarquía.

La primer alternativa es la propuesta por Fowler y la más simple. La principal ventaja de esta
alternative es que no requiere cambiar la clase Component; su principal desventaja es que si se le
agregan mensajes a la interfaz de Component el NullComponent los heredará y si no se recuerda
reescribirlos en el NullComponent con el comportamiento correcto para el NullComponent el programa
tendrá comportamientos inesperados. La segunda alternativa no tiene la desventaja que vimos en la
primera y es por eso que suele preferirse sobre ella.

Luego de armar la jerarquía se deberán sobrescribir todos los mensajes de la interfaz de Component
en NullComponent con un comportamiento vacío. Luego de realizar esto se reemplazarán las asignaciones de
null a la variable de instancia. Por ejemplo:

\begin{code}
Context>>initialize
    component := null.

"Pasara a ser"

Context>>initialize
    component := NullComponent new.
\end{code}

Algunas asignaciones pueden tener como lado derecho el envío de un mensaje el cual puede devolver 
null. Esos casos deben reemplazarse por una delegación que permita asignar el Null Object:

\begin{code}
Context>>sendTask
    component := self latestComponent.

"Se reemplazara por:"

Context>>assignComponentWith: aComponentOrNull
    component := aComponentOrNull ifNil: [NullComponent new] ifNotNil: [aComponentOrNull].

Context>>sendTask
    self assignComponentWith: (self latestComponent).
\end{code}

Se agrega un mensaje que asignará a la variable de instancia una instancia de NullComponent cuando
el valor que devuelva la colaboración del lado derecho sea null. Esto debe ser así cuando no tenemos
control sobre esas colaboraciones o queremos encapsular la utilización del NullComponent a cierta parte
del código, si se reemplazan todos los lugares donde se utiliza un null por un Component por un NullComponent
entonces el mensaje de asignación no debería ser necesario.

Luego de realizar las operaciones anteriores la variable de instancia \lstinline{component} no
debería contener en ningún caso null, solo instancias de Component o NullComponent. El siguiente y
último paso es reemplazar los condicionales por el envío de mensajes polimórficos y el traslado
del comportamiento de null a el NullComponent:

\begin{code}
Context>>launchRocket
    rocketHeight := component ifNil: [0] ifNotNil: [component ignite].

"Luego de aplicar el refactoring"

NullComponent>>ignite
    ^0

Context>>launchRocket
    rocketHeight := component ignite.
\end{code}



\section{Descripción completa de la funcionalidad del refactoring implementado}

El modelo de IntroduceNullObject es más complejo que el de ExtractToMethodObject. Ambos fueron desarrollados
% REf a TDD
utilizando TDD y la principal diferencia que se encontró es que al empezar a desarrollar de manera incremental
las precondiciones del refactoring eran complejas y requerían que las estructuras recibidas
por el objeto central del modelo, el encargado de aplicar el refactoring, una instancia de la clase
\lstinline{IntroduceNullObject}, fueran también complejas (colleciones con varios niveles de profundidad).
Resultó conveniente repartir las responsabilidades y encapsular las distintas estructuras que necesita
el refactoring en otros objetos que luego recibirá este. Las precondiciones chequeadas por el refactoring
se redujeron porque los objetos que recibe son válidos entonces las validaciones espcíficas de esas estructuras
están encapsuladas en esos objetos.

El refactoring se utiliza de la siguiente manera:

\begin{code}
refactoring := IntroduceNullObject
    on: 'ivar1'
    of: aRocket class
    usingAsConcreteClass: ConcreteFuelTank
    usingAsNullClass: NullFuelTank
    for: replacementParameters
refactoring apply.
\end{code}

\lstinline{IntroduceNullObject} es subclase de \lstinline{Refactoring} y por lo tanto sobrescribe el
mensaje \lstinline{apply}. Los colaboradores que recibe en el mensaje de creación de instancia son 
lo que necesita para poder aplicar el refactoring.

\subsection*{La variable de instancia y la clase}
En el keyword \lstinline{on:} recibe el nombre de la variable de instancia que se reemplazará por el
Null Object. Hasta ahora el refactoring Introduce Null Object parecía aplicarse a un tipo. El tipo
que utilizamos de referencia era Componente y los cambios, reemplazo de asignaciones de null o 
chequeos por null, se realizaban sin un scope determinado, es decir, se aplicaban a lo largo de todo
el sistema. Realizar algo así en un sistema dinámico como Cuis no es posible sin sacrificar
demasiada confianza sobre la preservación del comportamiento del refactoring. El proceso para encontrar
todos los lugares en los que se utiliza una instancia de la clase Component no es claro y, aunque lo
fuera, como los tipos son dinámicos la variable podría contener un conjunto de tipos durante su
vida, no solo Component, dependiendo el momento de ejecución. Por último siempre queda el problema de
la metaprogramación que vuelve inútil cualquier intento de inferencia de tipos estática. Por esta
razón decidimos darle al cambio un scope determinado y que el usuario guíe al refactoring con su
conocimiento del modelo.

El scope elegido es el de una clase. La clase provee un equilibrio entre el método, que sería
demasiado restrictivo, probablemente existan pocos casos en los que se justifique introducir este
refactoring solo para eliminar los condicionales de un solo método, y todo el sistema, ya que no
existe un scope claro más grande que la clase o por lo menos Cuis no lo provee ya que las categorías
o los paquetes no permiten ese tipo de funcionalidad. La clase que se utilizará como contexto es la 
recibida en el keyword \lstinline{of:}.

Dentro de una clase se eligirá un colaborador interno o variable de instancia en particular sobre la
cual se realicen chequeos por nil para aplicar el refactoring. Al no contar con un tipo específico
para buscar todas las variables es necesario fijar la o las variables que el programador, por su
conocimiento del modelo, ya sabe que deberían pertenecer a ese tipo. Esto se apoya en las ventajas
ya expuestas de floss refactoring, el caso en el que el programador tiene claro el cambio que quiere
realizar y la herramienta lo automatiza para reducir la posibilidad de errores y aumentar la
velocidad de ejecución. La herramienta no asume entender el modelo ni poder cambiarlo sin guía del
usuario. Se elige como variable a fijar una variable de instancia porque son las variables que están
disponibles a través de todo el scope de la clase y son más comunes que las variables de clase o
las variables de pool.

Todo el refactoring tendrá como centro a la variable de instancia elegida, todo los condicionales
modificados serán sobre esa variable. La única precondición que solo incluyea al la variable de
instancia y la clase es que la variable pertenezca a la clase.

\subsection*{La jerarquía de Null Object}

La jerarquía que se asumirá será aquella en la que Component y NullComponent heredan de
AbstractComponent, veremos por qué más adelante. Sin embargo, no es necesario que efectivamente la
implementen, no es una precondición. La única precondición con respecto a las clases Component y
NullComponent es que no sean iguales. Si se utilizara la misma clase no se podrían enviar mensajes
polimórficos que se respondan de forma distinta dependiendo el tipo de la variable.

\subsection*{Los argumentos para los condicionales a reemplazar}

Los condicionales a reemplazar ya están determinados por la variable de instancia y su clase. Smalltalk no
cuenta con condicionales como parte de su sintaxis, éstos se implementan con polimorfismo. Por lo tanto,
los tipos de condicionales soportados por el refactoring no son más que un conjunto mensajes:

\begin{itemize}
    \item Nil Selectors
    \begin{itemize}
        \item \lstinline{ifNil:}
        \item \lstinline{ifNil:ifNotNil:}
        \item \lstinline{ifNotNil:}
        \item \lstinline{ifNotNil:ifNil:}
    \end{itemize}

    \item Boolean Selectors
    \begin{itemize}
        \item \lstinline{ifTrue:}
        \item \lstinline{ifTrue:ifFalse:}
        \item \lstinline{ifFalse:}
        \item \lstinline{ifFalse:ifTrue:}
    \end{itemize}
\end{itemize}

Los Nil Selectors siempre tienen que tener como receptor del mensaje a la variable de instancia y los
Boolean Selectors tienen que tener como receptor del mensaje a un envío de mensaje \lstinline{isNil} a la
variable de instancia:

\begin{code}
"Nil Selector: ejemplo de receptor"
component ifNil: [^4]    

"Boolean Selector: ejemplo de receptor"
component isNil ifTrue: [^4]    
\end{code}

Todos los condicionales soportados serán reemplazados por el envío de un mensaje polimórfico:

\begin{code}
Context>>fuel
    component ifNil: [0] ifNotNil: [component fuelLeftIn: unit]

"Pasara a ser:"
Context>>fuel
    component polymorphicSelector: units

"Agregando:"
Component>>polymorphicSelector: aUnit
    ^self fuelLeftIn: aUnit

NullComponent>>polymorphicSelector: aUnit
    ^0
\end{code}

El usuario deberá elegir el selector polimórfico y los nombres de los parámetros para las variables
a parametrizar. En el ejemplo anterior el selector polimórfico es \lstinline{polymorphicSelector} y
el nombre del parámetro \lstinline{aUnit}.

\section{Funcionalidad de ReplaceIfNilWithPolymorphismParameters}

\lstinline{ReplaceIfNilWithPolymorphismParameters} es una clase que representa los argumentos necesarios
para reemplazar un chequeo por null con polimorfirsmo. Los colaboradores internos de la clase son el
\lstinline{methodNode} del método, la raíz del AST, en el cual se encuentra el chequeo por null,
el \lstinline{messageNode} correspondiente al chequeo por null y una instancia de
\lstinline{VariablesToParametrizeKeywordsDefinitions}. Los dos primeros identifican y referencian al
chequeo por null que reemplazaremos. El tercero es un objeto que contiene la definición del 
mensaje polimórfico: los keywords, qué variable a parametrizar irá en qué keyword y los nombres de
los parámetros.

\lstinline{ReplaceIfNilWithPolymorphismParameters} valida que el \lstinline{messageNode} sea un mensaje
soportado por el refactoring.

% WRITE Explicar cómo se valida que el mensaje sea soportado y las complicaciones que trae eso.
Verificar que el \lstinline{MessageNode} represente un envío de mensaje soportado es un poco más 
complicado que verificar que el selector del nodo pertenezca al conjunto de selectores soportados
y que el receptor del mensaje sea una variable de instancia de la clase del método. La causa son algunas
optimizaciones que se realizan al construir el AST, en específico los MessageNode de un conjunto de mensajes,
dentro de los cuales encontramos a ifNil:ifNotNil: ifNotNil: y ifNotNil:ifNil:.




Además, verifica que la definición del mensaje polimórfico sea consistente con las variables a parametrizar
en los bloques y que no existan colisiones entre los nombres de los parámetros del mensaje polimórfico
y las variables temporales de los bloques que recibe el chequeo por null como argumento.






\subsection{The rest}

% WRITE ¿Por qué lo aplicamos solo en el contexto de una clase? ¿Qué otras alternativas se nos ocurrieron
% en un sistema dinámico como Smalltalk en el que no contamos con el tipo o la clase de una variable?
Ya veremos que es fácil pasar de realizar el cambio en el contexto de una clase a realizarlo en todo el sistema.
Bueno quizás no es tan fácil en un sistema dinámico como Smalltalk. Pero tiene ventajas y desventajas realizarlo
de esta manera, si lo vamos aplicando progresivamente podemos identificar más fácil si algo se rompe y dónde.


% WRITE Precursor del refactoring en referencia al paper de Methodology

% WRITE Ejemplo concreto

El cambio que implementamos está encapsulado en una clase. Si sucede que varias clases tienen el mismo
problema simplemente habría que implementarlo en cada clase. Por ahora no estamos contemplando este caso
porque siempre se crea un mensaje nuevo, habría que soportar métodos ya existentes para reutilizar esto.











% INO
- por qué se reemplazan todos los ifNilChecks y no está soportada la posibilidad de preservar algunos ifNilChecks? 
en el contexto de una clase no tiene sentido porque suponemos que la variable de instancia no
tomará más el valor nil. Pero si le agregamos un mensaje `isNull` a las clases entonces
podríamos seguir chequándolo. 

% INO
- ifNilChecks anidados

% Preservación del comportamiento
Aplicaré los refactorings a distintas partes de Cuis y después le voy a correr los tests.