% Descripción del refactoring
% historia, quién lo inventó?
% qué code smells motivan el introduce null object
% en qué consiste?
% en el paper del pattern muestran 3 formas de implementarla, está bueno repasarlas
% el chequeo por null de una variable. Reducir la cantidad de condicionales simplifica el código, lo
% vuelve más simple. El chequeo por null estará duplicado en cada utilización de esa variable
% WRITE En el paper de null object hay una buena introducción, si estoy falto de ideas puedo sacar de ahí.

% WRITE Ejemplo concreto
% WRITE Precursor del refactoring en referencia al paper de Methodology

% Precondiciones
% WRITE explicarl el por qué y dar ejemplos concretos
- no pueden haber returns
- no pueden haber referencias a super


% Limitaciones
- qué pasa si hay asignaciones que no es claro si es un null o no?
no estaría bueno tener un assignOptionalField para que en el contexto de la clase siempre sea NullObject?
- qué pasa si algún método devuelve esa ivar? no tendrá algún null check?
en el paper de null object lo resolvieron agregando un método getReference()
- qué pasa si se usa como colaborador en un envío de mensaje?
- qué pasa si hay chequeos por null que no se pueden refactorear?
se corta el refactoring o se reemplazan por isNull() y se refactorea lo que se puede

% Limitaciones
- se realiza en el contexto de una clase, si se realizara en un contexto más amplio qué problemas encontraríamos?
- no puede haber shadowing de variables porque dejó de estar permitido
% INO
- por qué se reemplazan todos los ifNilChecks y no está soportada la posibilidad de preservar algunos ifNilChecks? 
en el contexto de una clase no tiene sentido porque suponemos que la variable de instancia no
tomará más el valor nil. Pero si le agregamos un mensaje `isNull` a las clases entonces
podríamos seguir chequándolo. 



% Parametrización
% WRITE explicar a nivel código que se recibe, qué es parametrizable y qué no

% Interfaz de usuario (UI & UX)
- qué desaniman a los usuarios de utilizar los refactorings automáticos y qué hicimos al respecto?
    - no saber bien qué hace el refactoring
    explicaciones en texto y visualización de los cambios
    - hasta dónde llegan los cambios
    luego de aplicar el refactoring se muestra qué se identificó como una posible necesidad de cambio manual
- validaciones que impedirían aplicar el refactoring, cómo se muestran? Estas validaciones se
realizan antes de mostrar la UI. Completar la UI, osea configurar el refactoring, en algunos
casos puede ser una tarea que demande cierto tiempo, si ya sabemos que no se puede es preferible
que primero resuelva ese problema o directamente no aplique el refactoring y no pierda tiempo
configurándolo.



% WRITE dar ejemplos de todas estos items
En varios casos, se produce una explosión de posibilidades (como en las asignaciones de ivars) y
tomar una de todas sería sobresimplificar el problema y presentárselas al usuario sería
difícil debido a la complejidad que hay que trasmitir.
% INO
- ifNilChecks anidados
- las asignaciones a la variable de instancia en la que se está introduciendo el null object
reemplazamos las asignaciones de nil pero no las de colaboraciones.


% Implementación
% WRITE qué contar sobre la implementación y sobre el diseño?

% Preservación del comportamiento
% WRITE resumir cómo ganamos confianza y los tests más importantes
Aplicaré los refactorings a distintas partes de Cuis y después le voy a correr los tests.