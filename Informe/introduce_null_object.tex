\section{Motivación y smells}

Existen pocos lenguajes de programación orientados a objetos, y de uso extendido ninguno, que no
cuenten con una u otra forma de representar el valor especial null. La utilización de null conlleva
como principal riesgo el enviarle un mensaje o derefenciarlo, dependiendo el lenguaje utilizado, lo
cual resulta en un error en runtime o una terminación abnormal del programa. La forma más simple de
prevenir estos errores es realizar chequeos sobre las variables que se sospecha pueden contener null
para evitar enviarles mensajes. Veamos un ejemplo en la clase \lstinline{Behavior} de Cuis:

\begin{code}
Behavior>>allSuperclasses
	"Answer an OrderedCollection of the receiver's and the receiver's  
	ancestor's superclasses. The first element is the receiver's immediate  
	superclass, followed by its superclass; the last element is Object."
	| temp |
	^ superclass
		ifNil: [OrderedCollection new]
		ifNotNil: [temp := superclass allSuperclasses.
			temp addFirst: superclass.
            temp]
\end{code}

En este caso se verifica si la variable de instancia \lstinline{superclass} es nil para evitar
enviarle el mensaje \lstinline{allSuperclasses} y además por que la ausencia de superclase indica
que estamos en la raíz de la jerarquía.
% REF a Fowler
Si null conlleva tantos riesgos, ¿por qué se utiliza con tanta frecuencia? La utilización de null
puede ser la forma más simple y barata de implementar un modelo en determinado estadío o caso. Sin
embargo, si los chequeos por null abundan las causas más comunes son:

\begin{itemize}
    \item que la variable de instancia sea lo que se llama un temporary field, un colaborador que no
    forma parte de la esencia del objeto y por lo tanto no es necesario siempre, entonces en algunos casos
    es null.
    \item que falte una abstracción en el modelo para representar la ausencia de un tipo de objetos.
\end{itemize}

% REF a fowler y a woolf
Fowler y Woolf describen que la motivación para realizar el refactoring son repetidos chequeos por
null de un colaborador. Los condicionales reducen la entendibilidad del código y al chequear siempre
la misma condición producen código repetido, lo cual suele aumentar la posibilidad de que el
programador introduzca bugs olvidándose de chequear por null antes de enviarle un mensaje al
colaborador correspondiente. Una de las principales herramientas del paradigma de objetos para
lidiar con la proliferación de condicionales repetidos en el código es la utilización de
polimorfismo. En lugar de chequear manualmente en qué tipo de situación nos encontramos para decidir
qué hacer, se envía un mensaje polimórfico a un objeto que realizará la tarea correspondiente para
esa situación dependiendo en su tipo. La introducción de un Null Object sigue esta guía. Se
reemplazará la utilización de null por un Null Object, un objeto que representa la ausencia o la
nada del tipo correspondiente y encapsula el comportamiento necesario en las situaciones en las
cuales hay una ausencia de ese tipo. Al contar con un Null Object ya no es necesario verificar si el
objeto es null, nunca debería ser null, y se le puede enviar los mismos mensajes que a un Concrete
Object, ya que son polimórficos, contando con que el Null Object sabrá qué hacer. Además de reducir 
la complejidad del código la introducción del Null Object consigue que las extensiones futuras sean
más seguras, ya que no hay que chequear por null, y más mantenibles porque si se requiere cierto
comportamiento adicional en un caso en el que el colaborador está ausente el cambio quedará
encapsulado en la clase del Null Object.


% En el paper de null object hay una buena introducción, si estoy falto de ideas puedo sacar de ahí.


\section{¿En qué consiste?}

La esencia del refactoring es el reemplazo de condicionales que chequean si una variable es null
o no por el envío de un mensaje polimórfico. Conseguir ese objetivo requiere de varios pasos que tienen
varias alternativas de implementación:

\begin{enumerate}
    \item Crear una jerarquía para el Null Object.
    \item Reemplazar las asignaciones de null por asignaciones del Null Object.
    \item Reemplazar los condicionales que chequean null por envíos polimórficos al objeto.
    \item Mover el comportamiento requerido para los casos en los que el objeto es null al Null
    Object.
\end{enumerate}

Llamaremos NullComponent a la clase del Null Object y Component a la clase del objeto que representa
un componente que no es null. El NullComponent será polimórfico con el Component pero no contiene
estado porque sus métodos no tienen comportamiento, están vacíos, o devuelven alguna constante, en
ocasiones en forma de un Null Object de otro tipo. En un lenguaje dinámico como Smalltalk no es
necesario que exista una relación de herencia entre las clases para que puedan utilizarse
indistintamente como en el caso de lenguajes estáticamente tipados. De todas formas se elige
utilizar una relación de herencia y relacionar al Component y al NullComponent en una misma
jerarquía para dejar la relación entre los dos explícita. La jerarquía que los relaciona puede tomar
varias formas:

% DIAGRAM acá voy a meter el mismo diagrama que está en el paper de NullObject en el que muestran que
% las distintas formas de hacer la jerarquía.

La primer alternativa es la propuesta por Fowler y la más simple. La principal ventaja de esta
alternative es que no requiere cambiar la clase Component; su principal desventaja es que si se le
agregan mensajes a la interfaz de Component el NullComponent los heredará y si no se recuerda
reescribirlos en el NullComponent con el comportamiento correcto para el NullComponent el programa
tendrá comportamientos inesperados. La segunda alternativa no tiene la desventaja que vimos en la
primera y es por eso que suele preferirse sobre ella.

Luego de armar la jerarquía se deberán sobrescribir todos los mensajes de la interfaz de Component
en NullComponent con un comportamiento vacío. Luego de realizar esto se reemplazarán las asignaciones de
null a la variable de instancia. Por ejemplo:

\begin{code}
Context>>initialize
    component := null.

"Pasará a ser"

Context>>initialize
    component := NullComponent new.
\end{code}

Algunas asignaciones pueden tener como lado derecho el envío de un mensaje el cual puede devolver 
null. Esos casos deben reemplazarse por una delegación que permita asignar el Null Object:

\begin{code}
Context>>sendTask
    component := self latestComponent.

"Se reemplazará por:"

Context>>assignComponentWith: aComponentOrNull
    component := aComponentOrNull ifNil: [NullComponent new] ifNotNil: [aComponentOrNull].

Context>>sendTask
    self assignComponentWith: (self latestComponent).
\end{code}

Se agrega un mensaje que asignará a la variable de instancia una instancia de NullComponent cuando
el valor que devuelva la colaboración del lado derecho sea null. Esto debe ser así cuando no tenemos
control sobre esas colaboraciones o queremos encapsular la utilización del NullComponent a cierta parte
del código, si se reemplazan todos los lugares donde se utiliza un null por un Component por un NullComponent
entonces el mensaje de asignación no debería ser necesario.

Luego de realizar las operaciones anteriores la variable de instancia \lstinline{component} no
debería contener en ningún caso null, solo instancias de Component o NullComponent. El siguiente y
último paso es reemplazar los condicionales por el envío de mensajes polimórficos y el traslado
del comportamiento de null a el NullComponent:

\begin{code}
Context>>launchRocket
    rocketHeight := component ifNil: [0] ifNotNil: [component ignite].

"Luego de aplicar el refactoring"

NullComponent>>ignite
    ^0

Context>>launchRocket
    rocketHeight := component ignite.
\end{code}



\section{Descripción completa de la funcionalidad del refactoring implementado}

% WRITE Precursor del refactoring en referencia al paper de Methodology

% WRITE Ejemplo concreto

El cambio que implementamos está encapsulado en una clase. Si sucede que varias clases tienen el mismo
problema simplemente habría que implementarlo en cada clase. Por ahora no estamos contemplando este caso
porque siempre se crea un mensaje nuevo, habría que soportar métodos ya existentes para reutilizar esto.



\section{Descripción completa de la funcionalidad}











% INO
- por qué se reemplazan todos los ifNilChecks y no está soportada la posibilidad de preservar algunos ifNilChecks? 
en el contexto de una clase no tiene sentido porque suponemos que la variable de instancia no
tomará más el valor nil. Pero si le agregamos un mensaje `isNull` a las clases entonces
podríamos seguir chequándolo. 

% INO
- ifNilChecks anidados

% Preservación del comportamiento
Aplicaré los refactorings a distintas partes de Cuis y después le voy a correr los tests.