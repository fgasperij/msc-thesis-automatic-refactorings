\section{Introducción a los refactorings, su historia y razón de ser}
% De dónde salieron los refactorings
\subsection{Desarrollo de software evolutivo}
% Los proyectos de software evolucionan
Los refactorings nacen de una característica esencial del software productivo: el cambio.
Lehman, en 1969, fue uno de los primeros en estudiar la evolución y el mantenimiento del software. Sus 
investigaciones resultaron en un cambio de perspectiva sobre el mantenimiento de software que pasó 
a verse como una forma de desarrollo evolutivo. 
% REF cita a la survey de Lientz y Swanson a la que hacen referencia acá
% https://en.wikipedia.org/wiki/Software_maintenance#cite_note-csse.monash.edu.au-4 Lientz, B.P. and
% Swanson, E.B., Software Maintenance Management, A Study Of The Maintenance Of Computer Application
% Software In 487 Data Processing Organizations. Addison-Wesley, Reading MA, 1980.
[Lientz y Swanson] analizó la proporción de costos que representaban los distintos tipos de mantenimientos:

% FORMAT pasarlo a description?
\begin{itemize}
    \item Adaptaciones: modificationes para adaptarse cambios en su entorno (DBMS, OS).
    \item Mejoras: implementación de requerimientos que cambiaron o son nuevos sobre la funcionalidad.
    \item Correcciones: diagnóstico y corrección de errores.
    \item Preventivos: cambios para incrementar la mantenibilidad del software para prevenir problemas.
\end{itemize}

Los primeros dos tipos de actividades de mantenimiento representaban el 75\% de los costos de mantenimiento,
lo cual deja en claro la visión del mantenimiento como un desarrollo evolutivo. Lehman además propuso
que esa evolución incrementa la complejidad de los sistemas. Al incrementarse el número de entidades
que componen un sistema las interacciones que se producen entre ellos puede aumentar exponencialmente
hasta llegar un punto en el cual no es posible entenderlas. En el contexto de un proyecto de software
esto implicaría que el riesgo de romperlo al modificarlo o extenderlo sería demasiado alto. Casos así
% REF crisis del software http://homepages.cs.ncl.ac.uk/brian.randell/NATO/NATOReports/index.html
llevaron a la crisis del software.
No existe una métrica clara de la complejidad de un sistema de software pero se utilizan algunas aproximaciones
% REF cyclomatic complexity Mc Cabe
como la complejidad ciclomática de Mc Cabe. Sin embargo, dado que la complejidad del software está fuertemente
asociada a su mantenibildad, se suele tratar la primera mejorando a la segunda. Es decir, se intenta
limitar el incremento de la complejidad utilizando técnicas que apuntan a preservar la mantenibilidad
del sistema.


\subsection{Calidad y mantenibilidad del software}
La calidad del software en este contexto se refiere a la calidad estructural, los atributos de calidad
no funcionales sobre los que se apoyan los requerimientos funcionales. No existe una métrica aceptada
% REF a cisq
de la calidad ya que puede ser entendida de distintas formas. Sin embargo, CISQ definió un conjunto de
características con las cuales todo software debería contar para aportar valor de negocio:

\begin{itemize}
    \item fiabilidad: la probabilidad de que el sistema falle, su estabilidad. El principal objetivo
    es evitar downtime del sistema.
    \item eficiencia: mide el grado con el cual cumple los requerimientos de los usuarios en
    terminos de tiempo de respuesta.
    \item seguridad: cuantifica el riesgo de que se encuentren vulnerabilidades que dañen al
    negocio.
    \item mantenibilidad: la capacidad del software de cambiar y adaptarse a las necesidades de los
    usuarios y el mercado.
\end{itemize}

La mantenibilidad vemos que es uno de los cuatros componentes de la calidad y, por lo que vimos
antes, presenta una gran oportunidad para reducir los costos de un proyecto de software. 
La mantenibilidad del software suele describirse en función de varios otros atributos de calidad como:

\begin{itemize}
    \item entendibilidad: cuán costoso es entender el sistema. El desarrollador debe entenderlo para
    poder manipularlo de cualquier manera sin romperlo. El tiempo que le toma y el riesgo que tiene
    de romperlo por falta de comprensión son costos afectados por este factor.
    \item cambiabilidad: cuán costoso es cambiar el sistema. En particular, cuán costoso es realizarle
    los cambios que el negocio y los usuarios demandan de él.
    \item reusabilidad: cuán costoso es reusar los componentes del software para proveer una nueva
    funcionalidad.
    \item testabilidad: cuán costoso es crear tests para verificar una funcionalidad.
    \item extensibilidad: cuán costoso es extender el sistema con nuevas funcionalidades. La diferencia
    con cambiabilidad es que en este caso la funcionalidad es nueva y en el otro ya existe pero es
    modificado su comportamiento.
    \item transferibilidad: cuán costoso es transferir el proyecto o parte de él a otro equipo de
    desarrollo.
\end{itemize}

El incremento de la complejidad se produce en gran parte debido a la erosión del diseño, lo cual
decrementa su mantenibilidad. La degradación del diseño se puede ver más claramente a través del
incremento de los costos de cada uno de los componentes de la mantenibilidad de un sistema. Por ejemplo,
un diseño que no previó necesaria la flexibilidad que se requiere para implementar una nueva funcionalidad
incrementará los costos de extensibilidad, el tiempo de desarrollo se verá afectado.


\subsection{Técnicas para preservar la mantenibilidad}

Las decisiones de mantenimiento pueden ser más eficientes aceptando esta realidad del proceso de
desarrollo, su esencia evolutiva. Existen varias metodologías de desarrollo de software con enfoques
distintos y prioridades diferentes. Las metodologías ágiles engloban a varios frameworks de desarrollo
que se contraponen a los procesos pesados más tradicionales y proponen procesos más livianos en los
cuales prima la aceptación del cambio como guía del desarrollo. Algunos ejemplos son:

% REF a los frameworks
\begin{itemize}
    \item extreme programming (XP)
    \item Kanban
    \item Scrum
\end{itemize}

Los proyectos de sotware industriales tienen restricciones de tiempo ajustadas entonces los
desarrolladores introducen modificaciones de la forma más veloz posible sin tener en cuenta la
pérdida de calidad. El desarrollador no modifica el diseño antes de extender o modificar el modelo,
entonces las modificaciones que le realiza lo vuelven más complejo. La erosión del diseño se produce
porque no es posible anticipar los cambios que se le realizarán al software en el futuro entonces el
diseño original no es apropiado para incorporar todos los cambios que se le realizan luego al
sistema. 
Una de las prácticas del proceso continuo que propone XP para evitar la erosión es la de refactoring.
Se utiliza en varios frameworks de desarrollo iterativo incremental pero no se ha visto integradas en
sistemas tradicionales con modelos de desarrollo de cascada lineales. El refactoring es una parte
integral del desarrollo en el contexto de las metodologías ágiles.

% ¿Qué son los refactorings?
% REF agregar referencia a la tesis de Opdyke
El término fue acuñado por Opdyke en su tesis de doctorado y luego popularizado por Fowler, uno de
% REF agregar referencia a el libro de Fowler
los mayores evangelistas de la metodología extreme programming, en su libro \textit{Refactoring:
Improving the design of existing code}. Un refactoring o reestructuración es una modificación al
% Cuál es el objetivo de los refactorings
software que no cambia su funcionalidad. El objetivo de la misma es mejorar la calidad del sistema
modificando su estructura interna para volverlo más mantenible, entendible o que se adapte mejor a
futuros cambios o funcionalidades que haya que agregarle. Por ejemplo, si se desea agregar una
funcionalidad y el diseño no la contempló originalmente se puede agregar al diseño actual o cambiar
el diseño primero para que agregar la funcionalidad sea más simple y se pueda seguir extendiendo el
software en esa dirección más fácilmente.


\section{Investigaciones sobre software refactorings}
Los software refactorings son investigados desde numerosas perspectivas. Alguno de los temas más
investigados son:
% REF a Trends, opportunities...
\begin{itemize}
    % REF a el paper que definía floss refactoring
    \item refactoring tools: qué factores afectan el uso de refactorings automáticos? qué
refactorings automáticos usan los programadores? cuáles no y por qué? cómo mejorar las herramientas actuales?
    \item la relación entre los bad smells y los refactorings que podrían ayudar a lidiar con ellos. No hay estudios
empíricos que lleguen a conclusiones claras sobre la utilidad de los code smells para lo
programadores o si ayudan a determinar que un refactoring es necesario en ese lugar o qué
refactoring es necesario.
    \item refactorings en artifacts que no son código: especificación de requerimientos, diseño de más alto nivel, documentación, etc.
    \item patrones de diseño: su utilidad, cuánto ayudarían, cuán de alto nivel se pueden hacer es una interrogante
    \item TDD, refactoring es una importante etapa de esta técnica 
    \item métricas del software sobre los atributos de calidad para medir el impacto de los
refactorings  
\end{itemize}


\section{Complejidades de estudiar refactorings}

\begin{itemize}
    \item cómo comparar las herramientas y los refactorings? taxonomía
    \item cómo determinar si un refactoring preserva el comportamiento? poco formal, la mayoría de
    los enfoques son semi formales o solo con los tests del sistema
    \item entender cómo realizan refactorings los desarrolladores actualmente? difícil, los más
    precisos son poco representativos, los más generales son poco precisos y solo uno analiza los
    cambios en continuo.
    \item métricas para determinar si un refactoring aumentó la calidad del software o no? redujo la
    complejidad? tampoco está claro cómo hacerlo.
\end{itemize}


\section{¿Para qué realizar cambios que no impactan en la funcionalidad del software?}
El software evoluciona porque a medida que el tiempo pasa los requerimientos que intenta satisfacer
cambian. Para satisfacer los nuevos requerimientos es necesario modificar y extender el sistema,
además de arreglar los posibles errores que surjan. Los atributos de calidad más relacionados con
esta parte del desarrollo del software son: 

\begin{itemize}
    \item extensibilidad
    \item mantenibilidad
    \item comprensiblidad
\end{itemize}


\section{¿Son útiles los refactorings?}
Los refactorings son útiles porque permiten preservar la calidad del software, principalment su:

\begin{itemize}
    \item extensibilidad
    \item mantenibilidad
    \item comprensiblidad
\end{itemize}

(Empirical study on the impact...)
Los refactorings aumentan la mantenibilidad del software.
(Practical Analysis for Refactoring)
Extreme Programming acepta que el software evoluciona y el diseño constantemente cambia. La
adaptación del software requiere energía del desarrollador constante y es necesaria para que la
complejidad no crezca demasiado. Cambiar el diseño aplicando refactorings para que la complejidad
crezca lo menos posible solo será posible minimizando la energía que tiene que poner el
desarrollador y esto se puede conseguir automatizando los refactorings.


\section{¿Qué relación tienen con la calidad del software?}
Permiten preservarla. Los 3 atributos mencionados en el punto anterior se van
degradando a medida que el software evoluciona y se produce un fenómeno conocido como erosión del
diseño. Los cambios que se introducen subsecuentemente en el software no fueron previstos por el
diseñador original del sistema y en consecuencia la calidad decrece. Los refactorings modifican el
diseño antes de agregar las nuevas funcionalidades para que el diseño pueda adoptar los nuevos
cambios sin perder calidad.


\section{¿Son útiles los refactorings automáticos? ¿qué se sabe?}
Detectar cuándo realizar un refactoring, dónde realizarlo y qué cambiar son todos problemas
íntimamente relacionados. Existen investigaciones que intentan procesar el código y realizarle
cambios sin intervención del desarrollador. Sin embargo, la mayoría de las herramientas automatizan
la ejecución del cambio, el desarrollador elige cuándo, dónde y qué cambio se realizará. La cantidad
de refactorings posibles es grande por lo cual se estima que sería útil contar con una herramienta
que le permita al desarrollador crear sus propios refactorings automatizados y luego utilizarlos
(Trends...). Hay pocos estudios en referencia a code smells, la detección de los mismos y su
utilización para elegir un refactoring no tiene atención.
(A Refactoring Tool for Smalltalk)
Las modificaciones que se le realizan a un programa pueden ser divididas en dos etapas:

\begin{itemize}
    \item refactoring del código/diseño para adaptarse mejor a las modificaciones
    \item las modificaciones. Si se cuenta con refactorings automáticos que preservan el comportamiento
\end{itemize}

para realizar la primer etapa entonces la única fuente de errores al introducir cambios en un
programa es la segunda etapa. Esto reduce la posible cantidad de errores agilizando el mantenimiento
del software.
(Programmer-Friendly...) Los dos principales riesgos al aplicar refactorings son:

\begin{itemize}
    \item introducir bugs
    \item tiempo consumido
\end{itemize}

los refactorings automáticos mitigan ambas.

(Automated refactoring of super-class method invocations to the Template Method design pattern) Los
principales caminos que se están investigando actualmente para la automatización de la
identificación de diseños pobres y sus correspondientes refactorings sin intervención del
desarrolladors son:

\begin{itemize}
    \item métodos basados en métricas: áreas del código con baja calidad son identificadas detectando
    los mínimos de alguna métrica de calidad.
    \item métodos basados en lógica: el código es traducido a un lenguaje lógico intermedio que es analizado
    con reglas que verifican la calidad de las relaciones para identificar defectos.
    \item métodos basado en búsqueda: la mejora del diseño se traduce a un problema de optimización de una función de 
    a fitness function whose search space consists of the alternative designs.
    % https://en.wikipedia.org/wiki/Fitness_function
    \item visualization techniques: differents forms of visualizing the code aim to aid the
    developer to gain new perspectives of the code that would allow him to spot flaws more easily.
\end{itemize}

Categorización de los métodos utilizados para realizar refactorings automáticos

\begin{itemize}
    \item método de aplicación: ¿cuán automático es? automatiza identificación, elección de nombres, aplicación del refactoring, cuándo, dónde.
    \item preservación del comportamiento: manual, semi-formal, formal.
    \item composición de los refactorings: dinámica o estática.
\end{itemize}

\section{¿Son útiles los refactorings de alto nivel? ¿qué se sabe?}
Existen opiniones encontradas. Algunos opinan que cuanto más se automatice mejor ya que modificar el
código es una operación delicada, menor intervención humana implicaría menor espacio para el error.
Sin embargo, estudios acerca de la utilización de estas herramientas no arrojan resultados claros
que indiquen que los desarrolladores las utilicen con la frecuencia esperada. Incluso la correlación
entre la complejidad del refactoring (cuán alto es su nivel) y la frecuencia de su utilización se
muestra inversa. No queda claro a qué se debe esto. Hay estudios que intentan entender a qué se debe
esto y cómo construir herramientas que automaticen los cambios y que los desarrolladores utilicen.
(A discussion of software..) Los refactorings deben ser más complejos para poder ayudar al
desarrollo de proyectos grandes. Por lo tanto, las herramientas deberían permitir componer
refactorings para poder construir más complejos.
(Practical Analysis for refactoring) La aplicación de patrones de diseño se correspondería con
refactorings compuestos que permitirían ahorrar mucha energía del desarrollador y explorar opciones
de diseño con un costo menor.
(A Refactoring Tool... A Compositional Paradigm) Los refactorings complejos deberían realizarse como
la composición de refactorings más simples automáticos. Algunos refactorings se realizan comúnmente
y es tedioso realizarlos incluso con refactorings automáticos más simples porque no es fácil
encontrar refactorings intermedios que simplifiquen la tarea (por ejemplo, introduce null object,
cómo lo partirías en refactorings simples?)
¿Qué forma toman los refactorings de alto nivel? por qué? Los refactorings de alto nivel son
combinaciones comunes de refactorings más simples que pueden o no tener una semántica clara a nivel
diseño del sistema. Los patrones de diseño son soluciones a problemas de diseño que surgen
frecuentemente al construir sistemas con lenguajes orientados a objetos. Los patrones de diseño son
soluciones vagamente definidas al nivel del diseño de un sistema que le permiten soportar cierta
funcionalidad con más calidad. Su presencia es común y es por eso que los refactorings de alto nivel
automáticos intentan aplicar estos patrones generalmente. Hay varios ejemplos de papers.

(A Methodology for the Automated Introduction of Design Pattern) Los refactorings de alto nivel
tienen más puntos de partida posibles y más destinos posibles ya que, a diferencia de refactorings
más primitivos, están definidos de forma más relajada. Se puede decir que cuanto más alto el nivel
de un refactoring menos específica es su definición. Se han clasificado los distintos puntos de
partida posibles: 

\begin{itemize}
    \item hoja en blanco: las entidades que se relacionarían en el patrón de diseño no se conocen
    todavía. Este caso no ocurre en la práctica usualmente.
    \item anti-patrón: este caso se debe a falta de conocimiento del programador. Se soluciona con
    educación, los posibles malos diseños son demasiados para considerarlos uno por uno.
    \item precursor: es un buen diseño para un caso más simple pero que ante nuevas necesidades de
    extensión debe cambiarse.
\end{itemize}

\section{¿Por qué refactorings automáticos que introducen patrones de diseño?}
Al automatizar refactorings se
quiere automatizar lo más posible para ahorrar la mayor cantidad de energía y tiempo del
desarrollador, y al nivel más expresivo posible para que la aplicación del refactoring esté lo más
cerca del nivel de abstracción al que está pensando el desarrollador el cambio. Las fuerzas que se
contraponen son expresividad y precisión. Cuanto más alto el nivel de abstracción, más difícil es
precisar a nivel de código en qué consiste el cambio. Los patrones de diseño presentan un balance
atractivo porque son cambios semántico suficientemente específicos para precisarlos en el código que
además están cerca de la forma que tiene el desarrollador de pensar su cambio.

¿En qué escenarios se utilizarían estos refactorings? El desarrollador tiene que agregar una nueva
funcionalidad al sistema pero su diseño actual no la acomoda de manera simple. El desarrollador
identifica dónde puede realizar un cambio para lograr la flexibilidad deseada y qué cambio quiere
realizar (la introducción de un patrónde diseño). En ese momento se puede automatizar la aplicación
del refactoring. patrones de diseño (null object pattern paper) Se ha explorado la introducción
automática de patrones de diseño orientada a root canal refactoring, ya que son herramientas que en
batch analizan todo el código, presentan los candidatos identificados y proveen la opción de aplicar
el refactoring. Las investigaciones se pueden clasificar según el tipo de patrones que analizaron:

\begin{itemize}
    \item estructurales (Abstract Factory y Composite)
    \item de comportamiento (Decorator, Template Method, Null Object y State/Strategy)
\end{itemize}

los métodos que utilizan para la identificación de oportunidades de mejora al diseño y la aplicación
de los respectivos refactorings también es variada. Sin embargo, el principal problema que
le vemos a estos trabajos es que no se ajustan a la forma de trabajo del programador.

\section{Preservación del comportamiento}
Este punto está presente en la misma definición de un refactoring y es de máxima importancia. Por el
momento la preservación de comportamiento no se puede definir de una forma que permita implementarla
en las herramientas. La preservación de la funcionalidad es difícil de formalizar y existen
distintos tipos de software para los cuales preservar el comportamiento implica más que preservar su
funcionalidad, por ejemplo:

\begin{itemize}
    \item tiempo de ejecución (sistemas de tiempo real)
    \item memoria utilizada y consumo de energía (sistemas embebidos) 
    \item condiciones de seguridad (sistemas en los cuales la seguridad es crítica)
\end{itemize}

Por esta razón un testing sistematizado y ajustado a los requerimientos de cada sistema particular
es la única y mejor herramienta con la que se cuenta actualmente.

(A Refactoring Tool for Smalltalk) No es posible asegurar que se preserva el comportamiento en un
lenguaje con tipado dinámico como Smalltalk, la única forma de converger a un programa correcto es a
través del análisis dinámico. Esto no lo realicé pero incluso el análisis dinámico se basa en una
suite de tests representativa.
(Improving refactoring tools in Smalltalk using static type inference) La única forma de asegurar
que los refactorings son correctos es con pruebas formales. Las herramientas actuales no realizan
esto porque la complejidad del software actual vuelve demasiado costoso aplicar modelos de
verificación formal a los programas que nos interesa reestructurar.
(Automated Application of Design Patterns: A Refactoring Approach) Perspectivas sobre la
preservación de comportamiento Las principales técnicas que se utilizan para lidiar con la
preservación de comportamiento son:

\begin{itemize}
    \item no prestarle atención
    \item semi formal para tener una referencia de lo pensado y confianza en ello
    \item verificación formal
\end{itemize}

No se utiliza la verificación formal porque pocos lenguajes de programación ampliamente utlizados
tienen una semántica formal y un compilador que la verifica. Además, la complejidad de las
demostraciones de preservación de comportamiento para transformaciones no triviales es intratable.

\section{Refactoring implementados en IDEs populares}
Enumeración y comparación de  las implementaciones de refactorings en IDEs.

\begin{itemize}
    \item Eclipse
    \item IntelliJ
    superficial de IntelliJ Pasos Elige el código Elige Delegate, Parameter, Method Elige nombre de la
    clase y del método Elige opciones sobre los parámetros Prevee los cambios y los confirma No se puede
    elegir cualquier parte del código, tiene que ser un conjunto de statements o expressions No
    parametriza el contexto de la clase, solo lo local
    \item NetBeans
    \item Visual Studio
    \item XCode
\end{itemize}
%    [Explicación](https://www.jetbrains.com/help/idea/extract-into-class-refactorings.html#extract_method_object)
 NetBeans no tiene ExtractToMethodObject tiene
extract method tradicional Visual Studio CodeRush Visual Assist Wing IDE XCode Extract to method
object IntelliJ Idea Solo extrae a una clase interna, lo cual simplifica bastante el refactoring
porque compartimos el scope de variables de instancia, de clase, etc. Visual Studio Solo realiza
extract method y el nuevo método pertenece a la misma clase. Si necesita devolver más de un
resultado utiliza los parámetros de salida de C\#. Eclipse Solo realiza extract method.