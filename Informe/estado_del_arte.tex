\section{Introducción a los refactorings, su historia y razón de ser}
% REF agregar cita sobre Lehman
% ¿Por qué la evolución incrementa la complejidad?
La erosión del diseño se produce porque no es posible anticipar los cambios que se le realizarán al
software en el futuro entonces el diseño original no es apropiado para incorporar todos los cambios
que se le realizan luego al sistema. El desarrollador no modifica el diseño antes de extender o
modificar el modelo, entonces las modificaciones que le realiza lo vuelven más complejo. Los
proyectos de sotware industriales tienen restricciones de tiempo ajustadas entonces los desarrolladores
introducen modificaciones de la forma más veloz posible sin tener en cuenta la pérdida de calidad.
% WRITE El incremento de la complejidad reduce su mantenibilidad. ¿Qué consecuencias negativas trae esto?
% ¿Qué técnicas existen para lidiar con este problema?
Existen numerosas técnicas
para minimizar o reducir el impacto negativo del cambio en los sistemas de software. Una metodología
general para desarrollar software que se basa en la aceptación del cambio del mismo es la conocida
% REF agregar referencia a extreme programming
extreme programming, la cual utiliza técnicas como:

\begin{itemize}
    \item scrum
    \item tdd
    \item unit testing
    \item refactoring
    \item pair programming
    \item sprints
    \item etc.
\end{itemize}

% ¿Qué son los refactorings?
El refatoring del software es una de ellas. Se utiliza en técnicas de desarrollo iterativo
incremental, no se han visto integradas en sistemas tradicionales con modelos de desarrollo de cascada lineales.
En el contexto de las metodologías ágiles los refactorings se realizan durante el desarrollo del
software como una parte integral del mismo y no como una etapa separada. El término fue acuñado por
% REF agregar referencia a la tesis de Opdyke
Opdyke en su tesis de doctorado y luego popularizado por Fowler, uno de los mayores evangelistas de
% REF agregar referencia a el libro de Fowler
la metodología extreme programming, en su libro \textit{Refactoring: Improving the design of existing code}.
Un refactoring o reestructuración es una modificación al software que no cambia su funcionalidad. El objetivo
de la misma es mejorar la calidad del sistema modificando su estructura interna para volverlo más mantenible,
entendible o que se adapte mejor a futuros cambios o funcionalidades que haya que agregarle. Por
ejemplo, si se desea agregar una funcionalidad y el diseño no la contempló originalmente se puede
agregar al diseño actual o cambiar el diseño primero para que agregar la funcionalidad sea más
simple y se pueda seguir extendiendo el software en esa dirección más fácilmente.








\section{Investigaciones sobre software refactorings}
Los software refactorings son investigados desde numerosas perspectivas. Alguno de los temas más
investigados son:
% REF a Trends, opportunities...
\begin{itemize}
    % REF a el paper que definía floss refactoring
    \item refactoring tools: qué factores afectan el uso de refactorings automáticos? qué
refactorings automáticos usan los programadores? cuáles no y por qué? cómo mejorar las herramientas actuales?
    \item la relación entre los bad smells y los refactorings que podrían ayudar a lidiar con ellos. No hay estudios
empíricos que lleguen a conclusiones claras sobre la utilidad de los code smells para lo
programadores o si ayudan a determinar que un refactoring es necesario en ese lugar o qué
refactoring es necesario.
    \item refactorings en artifacts que no son código: especificación de requerimientos, diseño de más alto nivel, documentación, etc.
    \item patrones de diseño: su utilidad, cuánto ayudarían, cuán de alto nivel se pueden hacer es una interrogante
    \item TDD, refactoring es una importante etapa de esta técnica 
    \item métricas del software sobre los atributos de calidad para medir el impacto de los
refactorings  
\end{itemize}


\section{Complejidades de estudiar refactorings}

\begin{itemize}
    \item cómo comparar las herramientas y los refactorings? taxonomía
    \item cómo determinar si un refactoring preserva el comportamiento? poco formal, la mayoría de
    los enfoques son semi formales o solo con los tests del sistema
    \item entender cómo realizan refactorings los desarrolladores actualmente? difícil, los más
    precisos son poco representativos, los más generales son poco precisos y solo uno analiza los
    cambios en continuo.
    \item métricas para determinar si un refactoring aumentó la calidad del software o no? redujo la
    complejidad? tampoco está claro cómo hacerlo.
\end{itemize}


\section{¿Para qué realizar cambios que no impactan en la funcionalidad del software?}
El software evoluciona porque a medida que el tiempo pasa los requerimientos que intenta satisfacer
cambian. Para satisfacer los nuevos requerimientos es necesario modificar y extender el sistema,
además de arreglar los posibles errores que surjan. Los atributos de calidad más relacionados con
esta parte del desarrollo del software son: 

\begin{itemize}
    \item extensibilidad
    \item mantenibilidad
    \item comprensiblidad
\end{itemize}


\section{¿Son útiles los refactorings?}
Los refactorings son útiles porque permiten preservar la calidad del software, principalment su:

\begin{itemize}
    \item extensibilidad
    \item mantenibilidad
    \item comprensiblidad
\end{itemize}

(Empirical study on the impact...)
Los refactorings aumentan la mantenibilidad del software.
(Practical Analysis for Refactoring)
Extreme Programming acepta que el software evoluciona y el diseño constantemente cambia. La
adaptación del software requiere energía del desarrollador constante y es necesaria para que la
complejidad no crezca demasiado. Cambiar el diseño aplicando refactorings para que la complejidad
crezca lo menos posible solo será posible minimizando la energía que tiene que poner el
desarrollador y esto se puede conseguir automatizando los refactorings.


\section{¿Qué relación tienen con la calidad del software?}
Permiten preservarla. Los 3 atributos mencionados en el punto anterior se van
degradando a medida que el software evoluciona y se produce un fenómeno conocido como erosión del
diseño. Los cambios que se introducen subsecuentemente en el software no fueron previstos por el
diseñador original del sistema y en consecuencia la calidad decrece. Los refactorings modifican el
diseño antes de agregar las nuevas funcionalidades para que el diseño pueda adoptar los nuevos
cambios sin perder calidad.


\section{¿Son útiles los refactorings automáticos? ¿qué se sabe?}
Detectar cuándo realizar un refactoring, dónde realizarlo y qué cambiar son todos problemas
íntimamente relacionados. Existen investigaciones que intentan procesar el código y realizarle
cambios sin intervención del desarrollador. Sin embargo, la mayoría de las herramientas automatizan
la ejecución del cambio, el desarrollador elige cuándo, dónde y qué cambio se realizará. La cantidad
de refactorings posibles es grande por lo cual se estima que sería útil contar con una herramienta
que le permita al desarrollador crear sus propios refactorings automatizados y luego utilizarlos
(Trends...). Hay pocos estudios en referencia a code smells, la detección de los mismos y su
utilización para elegir un refactoring no tiene atención.
(A Refactoring Tool for Smalltalk)
Las modificaciones que se le realizan a un programa pueden ser divididas en dos etapas:

\begin{itemize}
    \item refactoring del código/diseño para adaptarse mejor a las modificaciones
    \item las modificaciones. Si se cuenta con refactorings automáticos que preservan el comportamiento
\end{itemize}

para realizar la primer etapa entonces la única fuente de errores al introducir cambios en un
programa es la segunda etapa. Esto reduce la posible cantidad de errores agilizando el mantenimiento
del software.
(Programmer-Friendly...) Los dos principales riesgos al aplicar refactorings son:

\begin{itemize}
    \item introducir bugs
    \item tiempo consumido
\end{itemize}

los refactorings automáticos mitigan ambas.

(Automated refactoring of super-class method invocations to the Template Method design pattern) Los
principales caminos que se están investigando actualmente para la automatización de la
identificación de diseños pobres y sus correspondientes refactorings sin intervención del
desarrolladors son:

\begin{itemize}
    \item métodos basados en métricas: áreas del código con baja calidad son identificadas detectando
    los mínimos de alguna métrica de calidad.
    \item métodos basados en lógica: el código es traducido a un lenguaje lógico intermedio que es analizado
    con reglas que verifican la calidad de las relaciones para identificar defectos.
    \item métodos basado en búsqueda: la mejora del diseño se traduce a un problema de optimización de una función de 
    a fitness function whose search space consists of the alternative designs.
    https://en.wikipedia.org/wiki/Fitness_function
    \item visualization techniques: differents forms of visualizing the code aim to aid the
    developer to gain new perspectives of the code that would allow him to spot flaws more easily.
\end{itemize}

Categorización de los métodos utilizados para realizar refactorings automáticos

\begin{itemize}
    \item método de aplicación: ¿cuán automático es? automatiza identificación, elección de nombres, aplicación del refactoring, cuándo, dónde.
    \item preservación del comportamiento: manual, semi-formal, formal.
    \item composición de los refactorings: dinámica o estática.
\end{itemize}

\section{¿Son útiles los refactorings de alto nivel? ¿qué se sabe?}
Existen opiniones encontradas. Algunos opinan que cuanto más se automatice mejor ya que modificar el
código es una operación delicada, menor intervención humana implicaría menor espacio para el error.
Sin embargo, estudios acerca de la utilización de estas herramientas no arrojan resultados claros
que indiquen que los desarrolladores las utilicen con la frecuencia esperada. Incluso la correlación
entre la complejidad del refactoring (cuán alto es su nivel) y la frecuencia de su utilización se
muestra inversa. No queda claro a qué se debe esto. Hay estudios que intentan entender a qué se debe
esto y cómo construir herramientas que automaticen los cambios y que los desarrolladores utilicen.
(A discussion of software..) Los refactorings deben ser más complejos para poder ayudar al
desarrollo de proyectos grandes. Por lo tanto, las herramientas deberían permitir componer
refactorings para poder construir más complejos.
(Practical Analysis for refactoring) La aplicación de patrones de diseño se correspondería con
refactorings compuestos que permitirían ahorrar mucha energía del desarrollador y explorar opciones
de diseño con un costo menor.
(A Refactoring Tool... A Compositional Paradigm) Los refactorings complejos deberían realizarse como
la composición de refactorings más simples automáticos. Algunos refactorings se realizan comúnmente
y es tedioso realizarlos incluso con refactorings automáticos más simples porque no es fácil
encontrar refactorings intermedios que simplifiquen la tarea (por ejemplo, introduce null object,
cómo lo partirías en refactorings simples?)
¿Qué forma toman los refactorings de alto nivel? por qué? Los refactorings de alto nivel son
combinaciones comunes de refactorings más simples que pueden o no tener una semántica clara a nivel
diseño del sistema. Los patrones de diseño son soluciones a problemas de diseño que surgen
frecuentemente al construir sistemas con lenguajes orientados a objetos. Los patrones de diseño son
soluciones vagamente definidas al nivel del diseño de un sistema que le permiten soportar cierta
funcionalidad con más calidad. Su presencia es común y es por eso que los refactorings de alto nivel
automáticos intentan aplicar estos patrones generalmente. Hay varios ejemplos de papers.

(A Methodology for the Automated Introduction of Design Pattern) Los refactorings de alto nivel
tienen más puntos de partida posibles y más destinos posibles ya que, a diferencia de refactorings
más primitivos, están definidos de forma más relajada. Se puede decir que cuanto más alto el nivel
de un refactoring menos específica es su definición. Se han clasificado los distintos puntos de
partida posibles: 

\begin{itemize}
    \item hoja en blanco: las entidades que se relacionarían en el patrón de diseño no se conocen
    todavía. Este caso no ocurre en la práctica usualmente.
    \item anti-patrón: este caso se debe a falta de conocimiento del programador. Se soluciona con
    educación, los posibles malos diseños son demasiados para considerarlos uno por uno.
    \item precursor: es un buen diseño para un caso más simple pero que ante nuevas necesidades de
    extensión debe cambiarse.
\end{itemize}

\section{¿Por qué refactorings automáticos que introducen patrones de diseño?}
Al automatizar refactorings se
quiere automatizar lo más posible para ahorrar la mayor cantidad de energía y tiempo del
desarrollador, y al nivel más expresivo posible para que la aplicación del refactoring esté lo más
cerca del nivel de abstracción al que está pensando el desarrollador el cambio. Las fuerzas que se
contraponen son expresividad y precisión. Cuanto más alto el nivel de abstracción, más difícil es
precisar a nivel de código en qué consiste el cambio. Los patrones de diseño presentan un balance
atractivo porque son cambios semántico suficientemente específicos para precisarlos en el código que
además están cerca de la forma que tiene el desarrollador de pensar su cambio.

¿En qué escenarios se utilizarían estos refactorings? El desarrollador tiene que agregar una nueva
funcionalidad al sistema pero su diseño actual no la acomoda de manera simple. El desarrollador
identifica dónde puede realizar un cambio para lograr la flexibilidad deseada y qué cambio quiere
realizar (la introducción de un patrónde diseño). En ese momento se puede automatizar la aplicación
del refactoring. patrones de diseño (null object pattern paper) Se ha explorado la introducción
automática de patrones de diseño orientada a root canal refactoring, ya que son herramientas que en
batch analizan todo el código, presentan los candidatos identificados y proveen la opción de aplicar
el refactoring. Las investigaciones se pueden clasificar según el tipo de patrones que analizaron:

\begin{itemize}
    \item estructurales (Abstract Factory y Composite)
    \item de comportamiento (Decorator, Template Method, Null Object y State/Strategy)
\end{itemize}

los métodos que utilizan para la identificación de oportunidades de mejora al diseño y la aplicación
de los respectivos refactorings también es variada. Sin embargo, el principal problema que
le vemos a estos trabajos es que no se ajustan a la forma de trabajo del programador.

\section{Preservación del comportamiento}
Este punto está presente en la misma definición de un refactoring y es de máxima importancia. Por el
momento la preservación de comportamiento no se puede definir de una forma que permita implementarla
en las herramientas. La preservación de la funcionalidad es difícil de formalizar y existen
distintos tipos de software para los cuales preservar el comportamiento implica más que preservar su
funcionalidad, por ejemplo:

\begin{itemize}
    \item tiempo de ejecución (sistemas de tiempo real)
    \item memoria utilizada y consumo de energía (sistemas embebidos) 
    \item condiciones de seguridad (sistemas en los cuales la seguridad es crítica)
\end{itemize}

Por esta razón un testing sistematizado y ajustado a los requerimientos de cada sistema particular
es la única y mejor herramienta con la que se cuenta actualmente.

(A Refactoring Tool for Smalltalk) No es posible asegurar que se preserva el comportamiento en un
lenguaje con tipado dinámico como Smalltalk, la única forma de converger a un programa correcto es a
través del análisis dinámico. Esto no lo realicé pero incluso el análisis dinámico se basa en una
suite de tests representativa.
(Improving refactoring tools in Smalltalk using static type inference) La única forma de asegurar
que los refactorings son correctos es con pruebas formales. Las herramientas actuales no realizan
esto porque la complejidad del software actual vuelve demasiado costoso aplicar modelos de
verificación formal a los programas que nos interesa reestructurar.
(Automated Application of Design Patterns: A Refactoring Approach) Perspectivas sobre la
preservación de comportamiento Las principales técnicas que se utilizan para lidiar con la
preservación de comportamiento son:

\begin{itemize}
    \item no prestarle atención
    \item semi formal para tener una referencia de lo pensado y confianza en ello
    \item verificación formal
\end{itemize}

No se utiliza la verificación formal porque pocos lenguajes de programación ampliamente utlizados
tienen una semántica formal y un compilador que la verifica. Además, la complejidad de las
demostraciones de preservación de comportamiento para transformaciones no triviales es intratable.

\section{Refactoring implementados en IDEs populares}
Enumeración y comparación de  las implementaciones de refactorings en IDEs.

\begin{itemize}
    \item Eclipse
    \item IntelliJ
    superficial de IntelliJ Pasos Elige el código Elige Delegate, Parameter, Method Elige nombre de la
    clase y del método Elige opciones sobre los parámetros Prevee los cambios y los confirma No se puede
    elegir cualquier parte del código, tiene que ser un conjunto de statements o expressions No
    parametriza el contexto de la clase, solo lo local
    \item NetBeans
    \item Visual Studio
    \item XCode
\end{itemize}
%    [Explicación](https://www.jetbrains.com/help/idea/extract-into-class-refactorings.html#extract_method_object)
 NetBeans no tiene ExtractToMethodObject tiene
extract method tradicional Visual Studio CodeRush Visual Assist Wing IDE XCode Extract to method
object IntelliJ Idea Solo extrae a una clase interna, lo cual simplifica bastante el refactoring
porque compartimos el scope de variables de instancia, de clase, etc. Visual Studio Solo realiza
extract method y el nuevo método pertenece a la misma clase. Si necesita devolver más de un
resultado utiliza los parámetros de salida de C\#. Eclipse Solo realiza extract method.