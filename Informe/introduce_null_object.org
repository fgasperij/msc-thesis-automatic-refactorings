* ¿Qué problema resuelve Introduce Null Object?

Existen pocos lenguajes de programación orientados a objetos, y de uso extendido
ninguno, que no cuenten con una u otra forma de representar el valor especial
null. La utilización de null conlleva como principal riesgo el enviarle un
mensaje o derefenciarlo, dependiendo el lenguaje utilizado, lo cual resulta en
un error en runtime o una terminación abnormal del programa. La forma más simple
de prevenir estos errores es realizar chequeos sobre las variables que se
sospecha puede contener null para evitar enviarles mensajes. Veamos un ejemplo
en la clase ~Behavior~ de Cuis:

#+BEGIN_SRC 
Behavior>>allSuperclasses

  "Answer an OrderedCollection of the receiver's and the receiver's
  ancestor's superclasses. The first element is the receiver's immediate
  superclass, followed by its superclass; and subsequent superclasses,
  and proceeding as long as there is a non-nil superclass.""

  | temp |
  
  ^ superclass
    ifNil: [OrderedCollection new]
    ifNotNil: [
      temp := superclass allSuperclasses.
      temp addFirst: superclass.
      temp]
#+END_SRC

En este caso se verifica si la variable de instancia ~superclass~ es nil para
evitar enviarle el mensaje ~allSuperclasses~, y además, por que la ausencia de
superclase indica que estamos en la raíz de la jerarquía. Si null conlleva
tantos riesgos, ¿por qué se utiliza con tanta frecuencia?  La utilización de
null puede ser la forma más simple y barata de implementar un modelo en
determinado estado o caso. Sin embargo, si los chequeos por null abundan las
causas más comunes son \cite{fowler99_refac}:

- Que la variable de instancia sea lo que se llama un temporary field,
  un colaborador que no forma parte de la esencia del objeto y por lo
  tanto no es necesario siempre; en los casos en los que no es necesario
  es nil.

- Que falte una abstracción en el modelo para representar la ausencia de
  un tipo de objetos.

\cite{fowler99_refac} y \cite{woolf96_thenull} describen que la motivación para
realizar el refactoring son repetidos chequeos por nil de un colaborador. Los
condicionales reducen la entendibilidad del código y al chequear siempre la
misma condición producen código repetido, lo cual suele aumentar la posibilidad
de que el programador introduzca bugs olvidándose de chequear por nil antes de
enviarle un mensaje al colaborador correspondiente. Una de las principales
herramientas del paradigma de objetos para lidiar con la proliferación de
condicionales repetidos en el código es la utilización de polimorfismo. En lugar
de chequear manualmente en qué tipo de situación nos encontramos para decidir
qué hacer, se envía un mensaje polimórfico a un objeto que realizará la tarea
correspondiente para esa situación dependiendo de su tipo. La introducción de un
Null Object sigue esta guía. Se reemplazará la utilización de nil por un Null
Object, un objeto que representa la ausencia o la nada del tipo correspondiente
y encapsula el comportamiento necesario en las situaciones en las cuales hay una
ausencia de ese tipo. Al contar con un Null Object ya no es necesario verificar
si el objeto es nil, nunca debería ser nil, y se le pueden enviar los mismos
mensajes que a un Concrete Object, ya que son polimórficos, contando con que el
Null Object sabrá qué hacer. Además de reducir la complejidad del código la
introducción del Null Object consigue que las extensiones futuras sean más
seguras, ya que no hay que chequear por nil, y más mantenibles porque si se
requiere cierto comportamiento adicional en un caso en el que el colaborador
está ausente el cambio quedará encapsulado en la clase del Null Object.


* ¿Cuáles son los pasos para aplicarlo?

La esencia del refactoring es el reemplazo de condicionales que chequean si una
variable es nil o no por el envío de un mensaje polimórfico. Conseguir ese
objetivo requiere a grandes rasgos los siguientes pasos:

1. Crear una jerarquía para el Null Object.

2. Reemplazar las asignaciones de nil por asignaciones del Null Object.

3. Reemplazar los condicionales que chequean nil por envíos polimórficos al
   objeto.

4. Mover el comportamiento requerido para los casos en los que el objeto es nil
   al Null Object.

El paso 1 es el único que debe realizarse antes que el resto, los demás se
pusieron en cierto orden para mayor claridad pero no es necesario que se
realicen en ese orden para todos los chequeos por nil, podrían realizarse para
cada chequeo por nil todos antes de pasar al siguiente.

Además, es importante aclarar que estos pasos asumen que el scope del Null
Object es una clase. Si el scope fuera todo el sistema habría que considerar que
quizás el valor del ivar que contiene al Null Object puede ser la respuesta de
un mensaje y el emisor del mensaje debería también ser modificado para colaborar
con el Null Object y no con nil. Por ejemplo:

#+BEGIN_SRC
Client>>doSomething
  context mayReturnNilMessage
    ifNil: [^0]
    ifNotNil: [ ^self somethingThatOnlyNeedsToBeDoneWhenAnswerIsNotNull ].
    
"Asumamos que ContextClass es modificada de forma tal que mayReturnNilMessage
conteste aComponent o aNullComponent, pero nunca nil. De se así, en los casos
que conteste aNullComponent se evaluará el bloque pasado ifNotNil: el cual
enviará un mensaje que solo debería enviarse cuando la respuesta no es null,
lo cual es un comportamiento no deseado. Esto se puede adaptar a la respuesta de
un NullObject en lugar de nil de la siguiente manera:"

Client>>doSomething
  context wontReturnNilMessage polymorphicReplacement: self.

Component>>polymorphicReplacement: client
  ^client somethingThatOnlyNeedsToBeDoneWhenAnswerIsNotNull.

NullComponent>>polymorphicReplacement: client
  ^0.
#+END_SRC


** La jerarquía

Llamaremos ~NullComponent~ a la clase del Null Object y ~Component~ a la clase
del objeto que representa un componente que no es nil. El ~NullComponent~ es
polimórfico con el ~Component~ pero no contiene estado porque sus métodos no
tienen comportamiento: están vacíos, o devuelven alguna constante, en ocasiones
en forma de un Null Object de otro tipo. En un lenguaje dinámico como Smalltalk
no es necesario que exista una relación de herencia entre las clases o que
pertenezcan a la misma jerarquía para que puedan utilizarse indistintamente,
como es el caso en lenguajes estáticamente tipados. De todas formas, en este
trabajo se eligió utilizar una relación de herencia y relacionar al ~Component~
y al ~NullComponent~ en una misma jerarquía para que la relación entre las dos
sea explícita, lo cual podría incrementar la entendibilidad del modelo. La
jerarquía que los relaciona puede tomar varias formas como se ha descrito en
\cite{gaitani15_automat}:

#+BEGIN_SRC plantuml :file diagrams/introduce_null_object_hierarchy_simple.png
Context -> Component
Component <|-- NullComponent
#+END_SRC

#+RESULTS:
[[file:diagrams/introduce_null_object_hierarchy_simple.png]]

La primer y más simple alternativa es la propuesta por Fowler
\cite{fowler99_refac}. La principal ventaja de esta alternativa es que no
requiere cambiar la clase ~Component~, lo cual la hace una buena candidata
cuando el código de ~Component~ está en una librería por ejemplo; su principal
desventaja es que si se le agregan mensajes a la interfaz de ~Component~ el
~NullComponent~ los heredará y si no se recuerda reescribirlos en el
~NullComponent~ con el comportamiento correcto para el ~NullComponent~ el
programa tendrá comportamientos inesperados.

#+BEGIN_SRC plantuml :file diagrams/introduce_null_object_hierarchy_abstract.png
Context -> AbstractComponent
AbstractComponent <|-- Component
AbstractComponent <|-- NullComponent
#+END_SRC

#+RESULTS:
[[file:diagrams/introduce_null_object_hierarchy_abstract.png]]

La segunda alternativa no tiene la desventaja que vimos en la primera y es por
eso que suele preferirse por sobre ella. El único problema que podría
presentarse es si ~Component~ ya hereda de alguna clase en un lenguaje sin
herencia múltiple.

#+BEGIN_SRC plantuml :file diagrams/introduce_null_object_hierarchy_interface.png
interface IComponent
Context -> IComponent
IComponent <|.. Component
IComponent <|.. NullComponent
#+END_SRC

#+RESULTS:
[[file:diagrams/introduce_null_object_hierarchy_interface.png]]

Esta tercer alternativa es similar a la segunda pero no requiere que las clases
hereden de una clase en común sino que implementen una misma interfaz, lo cual
requiere que el lenguaje provea interfaces.


** Reemplazo de las asignaciones

Luego de armar la jerarquía, que por ahora asumiremos que se corresponde con la
segunda alternativa, se podrían implementar todos los mensajes de la interfaz de
~Component~ en ~NullComponent~ con un comportamiento vacío. Luego de realizar
esto se reemplazarán las asignaciones de nil a la variable de instancia. Por
ejemplo:

#+BEGIN_SRC 
Context>>initialize
  component := nil.

"Pasará a ser"

Context>>initialize
  component := NullComponent new.
#+END_SRC

Algunas asignaciones pueden tener como lado derecho el envío de un mensaje el
cual puede que en algunos casos responda ~nil~ y en otros no. Esos casos deben
reemplazarse por una delegación que permita asignar el Null Object cuando la
respuesta es ~nil~:

#+BEGIN_SRC 
Context>>performTask
    component := self mayAnswerNilMessage.

"Se reemplazará por:"

Context>>assignComponentWith: aComponentOrNil
  component :=
    aComponentOrNil ifNil: [NullComponent new] ifNotNil: [aComponentOrNil].

Context>>performTask
    self assignComponentWith: (self mayAnswerNilMessage).
#+END_SRC

Se agrega un mensaje que asignará a la variable de instancia una instancia de
~NullComponent~ cuando el valor que devuelva la colaboración del lado derecho
sea nil. Esto debe ser así cuando no tenemos control sobre esas colaboraciones o
queremos encapsular la utilización del ~NullComponent~ a cierta parte del
código, el scope de la clase ~Context~ como ya mencionamos antes por ejemplo. Si
se reemplazan todos los lugares, en todo el sistema, donde se utiliza un nil en
lugar de un ~Component~ por un ~NullComponent~ entonces el mensaje de asignación
no debería ser necesario.

Luego de realizar las operaciones anteriores la variable de instancia
~component~ no debería contener en ningún caso dentro del scope de la clae
~Context~ nil, solo instancias de ~Component~ o ~NullComponent~.


** Reemplazo de los condicionales

El siguiente y último paso es reemplazar los condicionales por el envío de
mensajes polimórficos y el traslado del comportamiento de nil al
~NullComponent~:

#+BEGIN_SRC 
CompiledMethod>>compilerClass
  ^self methodClass 
    ifNil: [Compiler] 
    ifNotNil: [:class | class compilerClass].

"Luego de aplicar el refactoring"

NullClass>>compilerClass
    ^Compiler

CompiledMethod>>compilerClass
    ^self methodClass compilerClass.
#+END_SRC

Este es un caso simple, más adelante, al describir la implementación de este
trabajo se verán las particularidades que pueden surgir en función de lo que
contienen los bloques ~ifNil~: e ~ifNotNil:~.


* Creación del refactoring y validaciones

El modelo de ~IntroduceNullObject~ es más complejo que el de
~ExtractToMethodObject~. Ambos fueron desarrollados utilizando TDD
\cite{beck02_testdri} y la principal diferencia que se encontró es que las
precondiciones del refactoring eran complejas y requerían que las estructuras
recibidas por el objeto central del modelo, el encargado de aplicar el
refactoring, una instancia de la clase ~IntroduceNullObject~, fueran también
complejas (colleciones con varios niveles de profundidad). Resultó conveniente
repartir las responsabilidades y encapsular las distintas estructuras que
necesita el refactoring en otros objetos que luego éste recibirá. Las
precondiciones chequeadas por el refactoring se redujeron porque los objetos que
recibe son válidos entonces las validaciones espcíficas de esas estructuras
están encapsuladas en esos objetos.

El refactoring se utiliza de la siguiente manera:

#+BEGIN_SRC
refactoring := IntroduceNullObject
    on: 'numerator'
    of: Fraction
    usingAsConcreteClass: Integer
    usingAsNullClass: NullInteger
    for: replacementParameters

refactoring apply.
#+END_SRC

~IntroduceNullObject~ es subclase de ~Refactoring~ y por lo tanto sobrescribe el
mensaje ~apply~.


** El scope del refactoring: la clase y su variable de instancia

Hasta ahora el refactoring Introduce Null Object parece aplicarse a un tipo. El
tipo que utilizamos de referencia era ~Component~ y los cambios, reemplazo de
asignaciones de nil o chequeos por nil, se realizaban sin un scope determinado,
es decir, se aplicaban a lo largo de todo el sistema sobre las variables de ese
tipo. Esto no es posible en Cuis porque es un sistema dinámico, las variables no
tienen tipo, solo los valores. Lo que sí sucede a menudo, es que se utilicen
variables que siempre contienen el mismo tipo. Los tipos de variables en Cuis son:

- argumento de método o bloque

- temporal de método o bloque

- variable de instancia

- variable de clase

- variable de pool

- variables globales, aquellas que se encuentran definidas en el diccionario
  global ~Smalltalk~.

Los tipos más utilizados son los tres primeros, que tienen scope de método o
bloque y de clase, repectivamente. En esta implementación el scope elegido fue
la clase y la variable de instancia en particular, porque son ampliamente
utilizadas y suelen contener el mismo tipo. El método es demasiado restrictivo,
probablemente existan pocos casos en los que se justifique introducir este
refactoring solo para eliminar los condicionales de un solo método. La clase que
se utilizará como contexto es la recibida en el keyword ~of:~ y en el keyword
~on:~ recibe el nombre de la variable de instancia que es chequeada por nil.  El
refactoring se aplicará para modificar los chequeos por nil que se realicen en
la clase sobre la variable de instancia recibida como parámetros. El
programador, por su conocimiento del modelo, ya sabe que deberían pertenecer a
ese tipo. Esto se apoya en las ventajas ya expuestas de floss refactoring, el
caso en el que el programador tiene claro el cambio que quiere realizar y la
herramienta lo automatiza para reducir la posibilidad de errores y aumentar la
velocidad de ejecución. La herramienta no asume entender el modelo ni poder
cambiarlo sin guía del usuario. 

*Validación sobre la variable de instancia y la clase*

La única precondición que incluye a la variable de instancia o a la clase es la
que verifica que la variable pertenezca a la clase.


** La jerarquía de Null Object

La jerarquía que se asumirá será aquella en la que ~Component~ y ~NullComponent~
heredan de ~AbstractComponent~, veremos por qué más adelante. Sin embargo, no es
necesario que efectivamente la implementen, no es una precondición. La única
precondición con respecto a las clases ~Component~ y ~NullComponent~ es que no
sean iguales. Si se utilizara la misma clase no se podrían enviar mensajes
polimórficos que se respondan de forma distinta dependiendo el tipo de la
variable.


** Los argumentos para los condicionales a reemplazar

Los condicionales a reemplazar ya están determinados por la variable de
instancia y su clase. Smalltalk no cuenta con condicionales como parte de su
sintaxis, éstos se implementan con polimorfismo. Por lo tanto, los tipos de
condicionales soportados por el refactoring no son más que un conjunto mensajes:

- Nil Selectors

  - ~ifNil:~

  - ~ifNil:ifNotNil:~

  - ~ifNotNil:~

  - ~ifNotNil:ifNil:~

- Boolean Selectors

  - ~ifTrue:~

  - ~ifTrue:ifFalse:~

  - ~ifFalse:~

  - ~ifFalse:ifTrue:~

Los Nil Selectors siempre tienen que tener como receptor del mensaje a la
variable de instancia y los Boolean Selectors tienen que tener como receptor del
mensaje a un envío de mensaje =isNil= a la variable de instancia:

#+BEGIN_SRC
"Nil Selector: ejemplo de receptor"
component ifNil: [^4]    

"Boolean Selector: ejemplo de receptor"
component isNil ifTrue: [^4]    
#+END_SRC

Todos los condicionales soportados serán reemplazados por el envío de un mensaje
polimórfico:

#+BEGIN_SRC 
Context>>fuel
    component ifNil: [unit zero] ifNotNil: [component fuelLeftIn: unit]

"Pasará a ser:"
Context>>fuel
    component polymorphicSelector: unit

"Agregando:"
Component>>polymorphicSelector: aUnit
    ^self fuelLeftIn: aUnit

NullComponent>>polymorphicSelector: aUnit
    ^aUnit zero
#+END_SRC

El usuario deberá elegir el selector polimórfico y los nombres de los parámetros
para las variables a parametrizar. En el ejemplo anterior el selector
polimórfico es ~polymorphicSelector~ y el nombre del parámetro ~aUnit~.

El keyword ~for:~ del mensaje de creación de instancias recibe una colección de
~ReplaceIfNilWithPolymorphismParameters~. Éstos objetos, su estructura y
comportamiento, serán descriptos en una sección dedicada exclusivamente a
ellos. Varias de las validaciones que se deben realizar sobre estos parámetros
ya están encapsuladas en ellos, por lo tanto, como los recibimos instanciados no
es necesario repetirlas aquí. Las validaciones que sí se les realizan a estos
parámetros aquí porque son particulares del ~IntroduceNullObject~ son:

- Los bloques no contienen referencias a ~super~: los bloques son los que reciben
  los selectores ya mencionados, Nil Selectors y Boolean Selectors. No pueden
  :REFERENCE:
  A la parte de ETMO en la que explico esto.
  :END:
  contener ~super~ por la misma razón que los métodos de ~ExtractToMethodObject~
  no pueden.
  
- Los bloques no contienen asignaciones a variables que no son temporales del
  bloque: en este caso se decidió no incluir estos casos en el scope para
  priorizar la simplicidad de la primer versión (se puede encontrar una
  explicación más detallada en la sección
  \ref{sec:etmo_asignaciones_a_no_temporales}). La detección en este caso
  utiliza una instancia de ~EntranceExitBlockEnumerator~, clase creada por este
  trabajo, que permite evaluar un bloque al visitar y al salir de cada nodo del
  AST de un método. Se implementó de esta forma porque las únicas variables que
  se pueden asignar son las temporales de los bloques, por lo tanto es necesario
  contar con el conjunto de variables asignables o con las no asignables. El de
  no asignables es más heterogéneo (incluye las temporales del método, los
  parámetros, las de instancia, las de clase y las de pools) y complicado de
  generar. Las asignables, las temporales de los bloques, cambian según el nodo
  en el que estemos:

  #+BEGIN_SRC
  Example>>value
    self do: [ | firstLevelBlockTemp |
      "Acá la única asignable es firstLevelBlockTemp."

      self do: [ | secondLevelBlockTemp |
	"Acá las asignables son { firstLevelBlockTemp, secondLevelBlockTemp }."
	...].
 
      "Acá la única asignable VUELVE A SER firstLevelBlockTemp."
    ]
  #+END_SRC
  
  El ~EntranceExitBlockEnumerator~ permite agregar al conjunto de asignables
  todas las temporales de un bloque al visitarlo y removerlas al salir de ese
  nodo.

- Los bloques no contienen return statements: si uno de los bloques contiene un
  return statement y el otro no ese comportamiento no es replicable con el envío
  de un mensaje polimórfico. Supongamos que el chequeo por nil es:

  #+BEGIN_SRC
  Context>>doSomething
    ivar ifNil: [ ^3 ] ifNotNil: [ self doSomethingElse ].

    ^2.
    
   "El refactoring lo modificaría de la siguiente manera:"
    
  Context>>doSomething
    ivar polymorphicSelector.

    ^2. 
  #+END_SRC
  
  El problema es que cuando ~ivar~ es un Null Object la respuesta de
  ~doSomething~ debería ser 3 pero no hay forma de hacer return de manera
  anticipada desde ~polymorphicSelector~ de ~doSomething~. Por esta razón no se
  permiten returns en los bloques.
  
- No debe haber chequeos duplicados: debe haber solo un
  ~ReplaceIfNilWithPolymorphismParameters~ por chequeo en la colección recibida
  en el keyword ~for:~. Los ifNils en una clase se pueden obtener evaluando una
  instancia de ~IfNilChecksFinder~, se encapsuló el comportamiento en esta clase
  porque el ~IntroduceNullObjectApplier~ también necesita obtener todos los
  ifNils para que el usuario pueda configurar cómo reemplazarlos. Ésta clase
  puede servir como base para implementar un detector de smells, en este caso
  ifs, en el futuro.
  
- El receptor de los mensajes debe ser la variable de instancia elegida: todos
  los ~ReplaceIfNilWithPolymorphismParameters~ representan un cheque por nil que
  es un ~MessageNode~ cuyo selector es pertenece a los conjuntos ya
  presentados. El receptor debe ser en todos los casos la variable de instancia
  elegida. Asumiendo que la variable de instancia es ~arguments~:

  #+BEGIN_SRC
  "VÁLIDO"
  arguments ifNil: [ self doSomething ].

  "INVÁLIDO"
  receiver ifNotNil: [ self doSomething ].
  #+END_SRC

  En el segundo caso aunque el selector pertenece a los permitidos el receptor
  del mensaje no es ~arguments~.
  
- Los ~MethodNode~ deben pertenecer a la jerarquía de ~aClassToRefactor~: los
  ~ReplaceIfNilWithPolymorphismParameter~ se corresponden con un chequeo por nil
  y este chequeo, que es un ~MessageNode~, un envío de un mensaje, se encuentra
  dentro de un método, es decir, es descendiente de un ~MethodNode~ en un
  AST. La clase de cada uno de estos métodos, aquella en la cual están
  compilados (~aMethodNode methodClass~), debe ser igual a la clase que se
  recibe en el keyword ~of:~ o una subclase de la misma. Veamos un ejemplo:

  #+BEGIN_SRC
  Object subclass: #MessageSend
    instanceVariableNames: 'receiver selector arguments'
    classVariableNames: ''
    poolDictionaries: ''
    category: 'Kernel-Objects'
  
  Object weakSubclass: #WeakMessageSend
    instanceVariableNames: 'selector shouldBeNil arguments'
    classVariableNames: ''
    poolDictionaries: ''
    category: 'Kernel-Objects'

  "Ambas clases tiene una ivar con nombre selector, por lo cual:"

  IntroduceNullObject on: 'selector' of: (MessageSend | WeakMessageSend) [..]
  
  "Es válido con cualquier de las dos clases. Sin embargo receiver solo es ivar
  de MessageSend, por lo tanto intentar aplicar el refactoring con ese nombre y
  WeakMessageSend es inválido:"
  
  IntroduceNullObject on: 'receiver' of: WeakMessageSend [..]
  #+END_SRC
  
- Los selectores de los mensajes polimórficos no se hayan definidos ni en la
  ~ConcreteClass~ ni en la ~NullClass~: si así fuera al aplicar el refactoring
  éstos serían sobrescritos. Quizás esto es lo que desea el usuario pero en pos
  de preservar la simpleza decidimos no incluir esta funcionalidad. Si el
  usuario desea sobrescribir un método deberá eliminarlo antes de aplicar el
  refactoring.


* ~ReplaceIfNilWithPolymorphismParameters~
  
:DIAGRAM:
Le schéma dans page cinq de le bloc-notes 
:END:

~ReplaceIfNilWithPolymorphismParameters~ es una clase que representa los
argumentos necesarios para reemplazar un chequeo por nil con polimorfirsmo:

#+BEGIN_SRC
Object subclass: #ReplaceIfNilWithPolymorphismParameters
  instanceVariableNames: 'messageNode methodNode definitions'
  classVariableNames: ''
  poolDictionaries: ''
  category: 'Refactoring'
#+END_SRC

Los colaboradores internos son:

- ~messageNode~: el nodo del AST correspondiente al mensaje de chequeo por
  nil. Este mensaje tiene como selector alguno de los Nil Selectors o de los
  Boolean Selectors. Un ~MessageNode~ por sí solo no tiene ninguna referencia al
  método al cual pertenece, por esta razón para poder reemplazar el chequeo por
  polimorfismo es necesario también contar con el ~MethodNode~, raíz del AST al
  que el ~MessageNode~ pertenece. Esto es así porque las modificaciones de
  código se realizan manipulando los ~String~ s correspondientes y
  recompilándolos en la clase. 

- ~methodNode~: la raíz del AST del ~messageNode~. Este colaborador indica en
  qué clase está compilado el método al cual pertenece el chequeo por nil.
  
- ~definitions~: una instancia de ~VariablesToParametrizeKeywordsDefinitions~
  que contiene la definición del mensaje polimórfico que permite saber qué
  compilar en la ~ConcreteClass~ y en la ~NullClass~ y cómo enviarlo para
  reemplazar el chequeo por nil:

  - los keywords

  - la variable a parametrizar que irá en cada keyword

  - los nombres de los parámetros
    
  - el orden de los keywords


** ~VariablesToParametrizeKeywordsDefinitions~
   
~VariablesToParametrizeKeywordsDefinitions~ es una colección de
~VariableToParametrizeKeywordDefinition~, notar el singular en los sustantivos
del nombre, por lo tanto primero explicaremos ese objeto.


*** ~VariableToParametrizeKeywordDefinition~

#+BEGIN_SRC 
Object subclass: #VariableToParametrizeKeywordDefinition
	instanceVariableNames: 'variableName keyword parameterName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Refactoring'
#+END_SRC

Este objeto representa la definición del keyword para una variable a
parametrizar. Las variables a parametrizar ya fueron explicadas en la sección
\ref{sec:variables_a_parametrizar} del ~ExtractToMethodObject~ para ese caso
particular. Utilizamos el mismo nombre aquí porque el concepto es el mismo. Se
extrae una porción de código fuente y existen un conjunto de variables que se
referencian desde dentro de esa porción, porque forman parte de su scope y por
lo tanto son accesibles desde dentro del mismo, pero se definieron fuera de la
misma. En este caso se extrae el envío de un mensaje que realiza el chequeo por
nil por el envío de otro mensaje. Las variables a parametrizar son las mismas
que mencionamos en la sección \ref{sec:variables_a_parametrizar} más las
temporales del método que en este caso no están definidas en la porción que se
extrae. Por lo tanto, son variables a parametrizar:

- Los parámetros del método.

- Las variables temporales del método.
  
- Las pseudovariables ~self~ y ~super~.

- Las variables del contexto de la clase (ivars, class vars, y pool vars).

En este caso las variables a parametrizar estarán referenciadas desde dentro de
los bloques que reciben los Nil Selectors y los Boolean Selectors. La búsqueda
de las variables a parametrizar en los bloque está encapsulada en la clase
~MessageSendingBlocksVariablesToExtractFinder~ ya que también es requerida por
la interfaz de usuario, el ~IntroduceNullObjectForm~, para presentarle al
usuario las configuraciones de cada variable.

Cada variable a parametrizar precisa un keyword y un nombre para su parámetro en
la definición del mensaje polimórfico. Este objeto encapsula a los tres
colaboradores: la variable a parametrizar, el keyword y el nombre del parámetro.
y valida al crear la instancia que:

- El nombre del parámetro es válido: para validarlo se utiliza el
  ~Scanner>>scanFieldNames~ ya que los parámetros tienen las mismas
  :REFERENCE:
  background identifier
  :END:
  restricciones que cualquier otro identifier.
  
- El keyword es válido: no debe ser vacío y todos sus caracteres deben
  cumplir con ~Character>>isValidInIdentifiers~.


*** Modelo

Veamos con un ejemplo cómo encapsulan estos objetos los parámetros necesarios
para especificar los keywords y los nombre de los parámetros para cada variable
a parametrizar, representando en conjunto el header y el envío del mensaje:

#+BEGIN_SRC
WeakMessageSend>>value
  ^ arguments
    ifNil: [
      self withEnsuredReceiverDo: [ :r | r perform: selector ]]
    ifNotNil: [
      self withEnsuredReceiverAndArgumentsDo: [ :r :a |
        r perform: selector withArguments: a ]]
	
"Luego del reemplazo"
WeakMessageSend>>value
  ^arguments passTo: self usingSelector: selector
  
ConcreteArguments>>passTo: aMesasgeSend usingSelector: aSelector
  aMessageSend withEnsuredReceiverAndArgumentsDo: [ :r :a |
    r perform: aSelector withArguments: a ]
#+END_SRC
\label{lst:weak_message_send_value}

En este caso ~VariablesToParametrizeKeywordDefinitions~ hubiera sido creado de
la siguiente manera:

#+BEGIN_SRC

VariablesToParametrizeKeywordDefinitions with: {
  VariableToParametrizKeywordDefinition
    forVariable: 'self'
    useKeyword: #passTo
    withParameterName: 'aMessageSend'.
  VariableToParametrizKeywordDefinition
    forVariable: 'selector'
    useKeyword: #usingSelector
    withParameterName: 'aSelector.}
#+END_SRC

Notar que el keyword ~#with~ recibe una ~OrderedCollection~ cuyo orden
corresponde al orden que tendrán los keywords en el selector del
mensaje.

Antes de crear la instancia se realizan las siguientes validaciones:

- El primer keywords debe tener un primer caracter válido: los identifiers
  permiten un conjunto de caracteres pero el primer caracter debe pertenecer a
  un subconjunto de éstos definido en ~Character>>isValidStartOfIdentifiers~.
  
- Los nombre de los parámetros no están repetidos.
  
- Los nombres de las variables no están repetidos.

Existe otro caso que es en el que no hay variables a parametrizar, el conjunto
es vacío. Este caso también es soportado por
~VariablesToParametrizeKeywordsDefinitions~. Se pueden crear instancias para ese
caso con:

#+BEGIN_SRC
VariablesToParametrizeKeywordsDefinitions withSelector: #polymorphicSelector
#+END_SRC

Ya que solo se precisa el selector elegido.


** Validaciones 
   
Las validaciones realizadas verifican la consistencia entre los colaboradores
recibidos ya que todos ya son instancias válidas de sus respectivas clases:

- Verificar que el ~MessageNode~ represente un envío de mensaje soportado:
  ~MessageNode>>selectorSymbol~ permite acceder al selector correspondiente al
  ~MessageNode~. En el caso de los siguientes mensajes, verificar que el
  selector del ~MessageNode~ sea uno de éstos:

  - ~ifNil:~

  - ~ifTrue:~

  - ~ifTrue:ifFalse:~

  - ~ifFalse:~

  - ~ifFalse:ifTrue:~

  y que el receptor se una variable de instancia o ~ivar isNil~, en el caso de
  los boolean selectors, es suficiente. Sin embargo, para los siguientes mensajes:

  - ~ifNil:ifNotNil:~

  - ~ifNotNil:~

  - ~ifNotNil:ifNil:~
    
  no es suficiente porque el código de los mismos es optimizado de forma que el
  AST que el ~Parser~ construye los transforma de la siguiente forma:
  
  | Orginal                             | Transformado                               |
  |-------------------------------------+--------------------------------------------|
  | ~ivar ifNil: [...] ifNotNil: [...]~ | ~ivar == nil ifTrue: [...] ifFalse: [...]~ |
  | ~ivar ifNotNil: [...]~              | ~ivar == nil ifTrue: [] ifFalse: [...]~    |
  | ~ivar ifNotNil: [...] ifNil: [...]~ | ~ivar == nil ifTrue: [...] ifFalse: [...]~ |
  
  Por lo tanto, se verifica también si el receptor es ~ivar == nil~ y el
  selector ~#ifTrue:ifFalse:~, lo cual hace que todo los chequeos por nil de esa
  forma que no fueron el resultado de una optimización también sean
  considerados.
  
- El ~MessageNode~ debe ser un descendiente del ~MethodNode~ en el AST: un
  ~MessageNode~ no tiene un ~MethodNode~ asociado, a partir de él no se puede
  saber a qué método pertenece, si es que pertenece a uno. La única forma de
  verificar la consistencia entre ambos es recorrer el AST desde el ~MethodNode~
  y entontrar al ~MessageNode~. Esto se realiza comparando el código fuente
  generado por el nodo ya que puede que sean objetos distintos.
  
- El ~MessageNode~ tiene que ser consistente con las
  ~VariablesToParametrizeKeywordsDefinitions~:

    - Cada una de las variables a parametrizar en el ~MessageNode~ debe tener
      una ~VariableToParametrizeKeywordDefinition~ en el
      ~VariablesToParametrizeKeywordsDefinitions~. Es decir, que cada variable a
      parametrizar deber tener especificado su keyword.
      
    - Cada uno de los ~VariableToParametrizeKeywordDefinition~ debe
      corresponderse con una variable a parametrizar el ~MessageNode~.
      
    - Los nombres de los parámetros especificados en
      ~VariablesToParametrizeKeywordsDefinitions~ para las variables a
      parametrizar deben ser distintos de los nombres de las variables
      temporales o argumentos de los bloques que se pasan como argumento al
      ~MessageNode~ y de los que se definen dentro de ellos:

      #+BEGIN_SRC
      Example>>value
        ivar ifNil: [:blockArg | | blockTemp |
          self checkSomethingAndDo: [:nestedBlockArg | | nestedBlockTemp |
            nestedBlockTemp := 1 ]]
      #+END_SRC
      
      En este ejemplo ninguna variable a parametrizar podrá tener como nombre de
      parámetro: ~blockArg~, ~blockTemp~, ~nestedBlockArg~ o
      ~nestedBlockTemp~. Esto vale para todos los bloques definidos sin importar
      el nivel de anidamiento. Cuis no permite shadowing.


** Protocolo/Funcionalidad que provee
   
~ReplaceIfNilWithPolymorphismParameters~ provee acceso y calcula todo lo que
necesita un objeto, en este caso el ~IntroduceNullObject~, para poder realizar
el reemplazo de un chequeo por el envío de un mensaje. En el futuro podría
utilizarse para refactorings que realicen otro tipo de reemplazos. Las funciones
principales son:

- Acceso al bloque nil y al bloque concreto. En particular si es el primer
  argumento o el segundo o si es nil (para el caso en el que no hay, como bloque
  conreto para ~#ifNil:~). Los casos posibles son:
  
  - ~ivar isNil ifTrue: nullBlock~
  - ~ivar isNil ifFalse: concreteBlock~
  - ~ivar isNil ifTrue: nullBlock ifFalse: concreteBlock~
  - ~ivar isNil ifFalse: concreteBlock ifTrue: nullBlock~
  - ~ivar ifNotNil: concreteBlock~
  - ~ivar == nil ifTrue: nullBlock ifFalse: concreteBlock~ que incluye el resto
    de las combinaciones de ~ifNil~ optimizadas.
  
  De éstos bloques el atributo más relevante es el rango que comprenden. Éste se
  obtiene a través del ~Encoder~.
  
- ~ReplaceIfNilWithPolymorphismParameters>>rangeOfMessageSend~: Cálculo del
  rango a reemplazar por el envío del mensaje polimórfico. Veamos unos
  ejemplos:
  
  [[file:~/Projects/Thesis/ino_range_to_replace.jpg]]
  
  En todos los casos, el rango de interés comprende el intervalo desde el
  caracter siguiente a la ~ivar~ hasta el fin ~MessageNode~. Ésta manera de
  calcularlo incluye todos los separadores (~Character>>isSeparator~) extra que
  puedan haber, como en el item 4, ya que ~Encoder~ incluye en el ~sourceRange~
  de un ~MessageNode~ desde la izquierda del receptor hasta la derecha del
  último argumento, que en este caso sería el ~]~ que cierra el último bloque.
  \label{itm:range_of_message_send_cases}
  
- ~ReplaceIfNilWithPolymorphismParameters>>rangesOfVariablesToParametrizeToReplacingParameter~:
  Construye una ~OrderedCollection~ de ~Association~ s cuyas keys son ~Interval~
  que representan un rango de código fuente, que será el de una variable a
  parametrizar, y el ~value~ el nombre del parámetro correspondiente a esa
  variable a parametrizar. Esta colección incluye todas las ocurrencias de las
  variables a parametrizar en el ~methodNode~ será responsabilidad del cliente
  que envía este mensaje elegir qué rangos son de su interés.


* Aplicación del refactoring

La aplicación del refactoring la realiza el objeto ~IntroduceNullObject~, ésta
consiste en:

- Reemplazar cada uno de los chequeos por nil.

- Delegar las asignaciones a la variable de instancia a ~assignOptionalField~.

- Pasar ~nil~ a los colaboradores externos en lugar del Null Object.


** Reemplazo de los chequeos por ~nil~

Los chequeos están especificados por los elementos de su colaborador interno
~replacementParameters~. Como cada uno de los elementos es una instancia de
~ReplaceIfNilWithPolymorphismParameters~ no solo especifican el chequeo por nil,
sino que también el keyword y el nombre del parámetro de cada variable a
parametrizar para realizar el reemplazo. Los cambios que incluye la aplicación
para cada cheque son:

- Agregar el mensaje al ~Component~.

- Agregar el mensaje al ~NullComponent~.

- Reemplazar el chequeo de nil por el envío del mensaje polimórfico.
  
El orden en el que se realizan no es relevante.

La compilación del nuevo método en las clases ~Component~ y ~NullComponent~ se
realiza de igual manera, lo que cambia es el bloque utilizado como fuente. Por ejemplo:

#+BEGIN_SRC
component ifNil: nullComponentBlock ifNotNil: componentBlock
#+END_SRC

Los mensajes que tienen un solo keyword no cuentan con un bloque para alguna de
las dos clases, en ese caso el método que se compilará será vacío ya que no se
requiere ningún comportamiento si el objeto tiene ese tipo. Veamos un ejemplo:

#+BEGIN_SRC
Context>>fuel
    ^component ifNotNil: [
        self fuelLevelChecked.
        component fuelLevel]

Component>>fuelLevelWithLog: context
    context fuelLevelChecked.
    ^self fuelLevel

NullComponent>>fuelLevelWithLog: context
    "Empty method"

Context>>fuel
    component fuelLevelWithLog: self
#+END_SRC

El chequeo por nil se realizó con el mensaje ~ifNotNil:~, por lo tanto si el
objeto es nil no se espera comportamiento alguno. Por esa razón el método en la
clase ~NullComponent~ resulta vacío.

La generación del código de los métodos requiere:

1. Obtener el código del bloque: se obtiene a través de
   ~ReplaceIfNilWithPolymorphismParameters>>(concrete|null)BlockSourceCode~.
   
2. Obtener el rango de las variables a parametrizar en el bloque para
   reemplazarlas por el nombre del parámetro:
   ~ReplaceIfNilWithPolymorphismParameters>>rangesOfVariablesToParametrizeToReplacingParameter~
   responde con los rangos de todas las ocurrencias de las variables a
   parametrizar en el método en el que se encuentra el ~ifNil~. Para poder
   realizar el reemplazo en el código del bloque es necesario:

   1. Seleccionar las ocurrencias de las variables a parametrizar en el bloque.
 
   2. Modificar los rangos de forma tal que sean relativos al bloque y no al
      método, es decir, que si tenemos este ~ifNil~:
      
      #+BEGIN_SRC
      Example>>value
        ivar ifNil: [ self doSomething ].
      #+END_SRC
      
      El rango que se recibe para la variable a parametrizar ~self~ es ~Interval
      from: 22 to: 25~, pero al realizar el reemplazo relativo al bloque, con el
      primer caracter del bloque igual a 0, el intervalo sería ~Interval from: 2
      to 5~. Para realizar esto simplemente se toma como offset el inicio del
      bloque y se resta el mismo al ~from~ y ~to~ de todos los rangos.
   
3. Reemplazar las variables a parametrizar por los nombres de los parámetros con
   la estructura generada en el paso anterior.

Una vez que se tiene el código de cada bloque compilarlo en la clase
correspondiente se realiza enviando ~Behavior>>compile~, precediendolo con el
message header que provee
~ReplaceIfNilWithPolymorphismParameters>>polymorphicMessageHeader~, ya que no
olvidemos que ~VariablesToParametrizeKeywordsDefinitions~ es su colaborador
interno.

Finalmente, se reemplaza el chequeo de nil por el envío del mensaje
polimórfico. Se toma el código fuente del método, se realiza el reemplazo y
luego se vuelve a compilar en su clase. La obtención del rango que comprende el
chequeo por nil se realiza considerando los mismos casos que ya fueron
descriptos en el item \ref{itm:range_of_message_send_cases}. La construcción del
envío del mensaje la realiza el
~ReplaceIfNilWithPolymorphismParameters>>polymorphicMessageSend~
correspondiente, ya que cuenta con ~VariablesToParametrizeKeywordsDefinitions~
como colaborador interno.


** Delegar las asignaciones a la variable de instancia
   
Dividimos las asignaciones en dos tipos, (i) las que asignan ~nil~ y (ii) y las
que asignan cualquier otro objeto o el resultado de una colaboración. El
reemplazo del primero tipo se realiza sustituyendo ~nil~ por ~NullObjectClass
new~ ya que como los Null Objects no tienen estado no requieren
inicialización:

#+BEGIN_SRC
instvar := nil.
"Se reemplaza por una asignación de un NullObject"
instvar := NullObject new.
#+END_SRC

Se podrían haber delegado todas las asignaciones a ~assignOptionalField~
resultando en ~self assignOptionalField: nil~ pero nos pareció más prolijo de
esta manera ya que es como creemos que el usuario lo hubiera escrito.

Hasta ahora los reemplazos de código que se han realizado son de todas las
ocurrencias de una variable, por ejemplo el reemplazo de las variables a
parametrizar en el Extract to method object por los nombres de los parámetros
correspondientes, o del código correspondiente a un ~MessageNode~. Los rangos de
todas las ocurrencias de una variable se pueden obtener con
~Encoder>>rangesForVariable:checkingType:ifAbsent~ y el rango de un
~MessageNode~, que es único, se puede obtener con
~Encoder>>rangeForNode:ifAbsent~. La diferencia de este reemplazo, es que ~nil~
es un ~VariableNode~ pero no necesitamos reemplazar todas las ocurrencias de la
misma, solo aquellas que se ubiquen del lado derecho de una asignación a la
variable de instancia del refactoring. Para obtener los rangos correspondientes
se identifican los nodos de las asignaciones correspondientes, los
~AssignmentNode~ del AST, y luego se filtran los rangos que se encuentran dentro
del rango del ~AssignmentNode~:

#+BEGIN_SRC 
ParseNodeEnumerator ofBlock: [ :node |
  (self isAssignmentToNil: node) ifTrue: [ | ranges assignmentRange nilRange |
    nilRanges := encoder rangeForNode: node value ifAbsent: [self shouldNotHappen].
    assignmentRange := encoder rangeForNode: node ifAbsent: [self shouldNotHappen].
    nilRangeOfThisAssignment := ranges detect: [:range | assignmentRange rangeIncludes: range first].

    nilAssignmentsRanges add: nilRange]].
#+END_SRC

En ambos casos decidimos no permitir al usuario elegir el nombre del mensaje.
El creador de instancias del Null Object es siempre ~new~ y el mensaje para
asignar la variable de instancia es siempre ~assignOptionalField~. Se realizó de
esta forma para reducir la carga de configuración del usuario. Veamos un ejemplo
del segundo tipo:

#+BEGIN_SRC 
"Asignación de un objeto o colaboración"
instavar := self doSomething.
"Se reemplaza por un envío a assignOptionalField"
self assignOptionalField: (self doSomething).
#+END_SRC

El reemplazo requiere obtener el rango a reemplazar, que se corresponde con el
rango del statement completo:

#+BEGIN_SRC
"node es el AssignmentNode correspondiente a instvar := ..."
assignmentRange := encoder rangeForNode: node ifAbsent: [self shouldNotHappen].
variableRanges := encoder rangeForNode: node variable ifAbsent: [self shouldNotHappen].
leftSideRange := (variableRanges select: [:r | r last < assignmentRange first]) last.
rangeToReplace := Interval from: (leftSideRange first) to: assignmentRange last.
#+END_SRC

Como podemos ver el ~encoder~ no cuenta con este rango, es necesario generarlo a
partir del comienzo del rango de ~assignmentNode variable~ y el final del rango
del ~assignmentNode~. El ~encoder~ tampoco cuenta con el rango del lado derecho
de la asignación, el rango correspondiente al ~AssignmentNode~, comprende desde
la posición del ~:=~ hasta el final del statement de asignación. Vale notar que
los statements de asignación no soportan la concatenación de llamadas con
~;~. El lado derecho se obtiene tomando la posición siguiente al ~:=~ hasta el
final y se usa como parámetro, rodeado por ~()~, para el envío de
~assignOptionalField:~.

:UNUSED_DIAGRAM:

Mostrar un diagrama de secuencia sobre cómo se produce un reemplazo

La idea es que se vean todos los pasos, qué objeto hace qué cosa y todos los
mensajes que se deben enviar para que se realice un reemplazo.

#+BEGIN_SRC plantuml :file diagrams/ino_replace_sequence.png
title Reemplazo de un ifNil

hide footbox

participant anApplier as INOApplier << (C, #ADD1B2) IntroduceNullObjectApplier >>
participant anIntroduceNullObject as INO << (C, #ADD1B2) IntroduceNullObject >>
participant replacementParameters as rps << (C, #ADD1B2) Collection<ReplaceIfNilWithPolymorphismParameters> >>
participant replacementParameter as rp << (C, #ADD1B2) ReplaceIfNilWithPolymorphismParameters >>

INOApplier -> INO : ""apply""
INO -> rps : ""do: [ :p | self applyWith: p ]""
rps -> INO : ""applyWith: replacementParameter""
INO -> rp : ""concreteBlockSourceCode""
return ""sourceCode""
INO -> rp : ""concreteBlockRange""
return ""blockRange""
INO -> INO : ""compile: sourceCode in: blockRange asPolymorphicMessageOnClass: concreteClass using: replacementParameter""
INO -> INO : ""rangesIn: blockRange toReplacementParametersFrom: replacementParameter""
return ""rangesToReplacingParameter""
INO -> rp : ""polymorphicMessageHeader""
INO -> concreteClass : ""compile: polymorphicMessageSourceCode""

... The same process is performed for the Null Block ...

INO -> INO : ""replaceNilCheckWithPolymorphicMessageSendUsing: replacementParameter""
INO -> rp : ""methodSourceCode""
return ""originalSourceCode""
INO -> rp : ""rangeOfMessageSend""
return ""rangeOfMessageSend""
INO -> rp : ""polymorphicMessageSend""
return ""polymorphicMessageSend""
INO -> originalSourceCode : ""copyReplacing: rangeOfMessageSend with: polymorphicMessageSend""

#+END_SRC

#+RESULTS:
[[file:diagrams/ino_replace_sequence.png]]

:END:

La compilación de este mensaje la realiza el siguiente mensaje:

#+BEGIN_SRC
compileAssignOptionalField

  | body header paramName selectorName |
  
  paramName := 'maybeNil'.
  selectorName := 'assignOptionalField'.
  header := selectorName, ': ', paramName, String newLineString, String newLineString, String tab.
  body := instVar, ' := ', paramName, ' ifNil: [ ', nullClass name, ' new ].'
  
  classToRefactor compile: header, body. 
#+END_SRC

La forma que tiene el código resultante es:

#+BEGIN_SRC
assignOptionalField: maybeNil

  ivar := maybeNil ifNil: [ NullObject new ]
#+END_SRC

El selector ~assignOptionalField~ no puede estar definido en la clase.


** Pasar ~nil~ a los colaboradores externos en lugar del Null Object
   
El refactoring es aplicado en el contexto de una clase, no en todo el
sistema. Por esta razón, es necesario preservar el tipo de los colaboradores que
enviamos hacia el resto del sistema. La variable de instancia, que luego de
aplicar el refactoring siempre será un objeto concreto o un Null Object pero
nunca ~nil~ en el contexto de la clase, se comparte con el sistema cuando:

- Es la repuesta de un mensaje.

- Es un argumento del envío de un mensaje.
  
Antes de aplicar el refactoring, el emisor del mensaje en el primer caso y el
receptor del mensaje en el segundo, recibían ~nil~ en los casos que ahora la
variable de instancia es un Null Object. Para no romper estos contratos se debe
seguir utilizando ~nil~ en esos casos. Para ello se debe:

1. Compilar un mensaje en la ~ConcreteClass~, que devolverá ~self~, y en la
   ~NullClass~, que devolverá ~nil~, que se llamará ~getReference~. El objetivo
   es poder obtener ~nil~ a partir de la variable de instancia en los casos
   correspondientes.
   
2. Reemplazar todas las ocurrencias de la variable de instancia como una
   respuesta o un argumento de esta forma:

   #+BEGIN_SRC
   "Como respuesta"
   ^ivar
   "pasa a ser"
   ^ivar getReference

   "Como argumento"
   anObject useCollaborator: ivar
   "pasa a ser"
   anObject useCollaborator: ivar getReference
   #+END_SRC
   
El paso 2 es más simple porque ~getReference~ es unario, por lo tanto no hay
casos en los que se tenga que especificar la precedencia con paréntesis.


* Interfaz de usuario

El usuario puede iniciar la interfaz para aplicar el refactoring desde el
listado de clases en el /System Browser/, porque lo que necesita seleccionar es
la clase a utilizar como contexto:

[[file:screenshots/ino/select_refactoring.png]]

La clase que se utilizará es la que esté seleccionada en el listado. Si no hay
ningún item seleccionado se le informa al usuario que debe seleccionar alguna
clase para poder aplicar el refactoring. En este caso seleccionamos la clase
~Browser~. En ese momento un ~IntroduceNullObjectRefactoringApplier~ es
instanciado y comienza a solicitarle los parámetros necesarios al usuario. Se le
pedirá que seleccione la variable de instancia de la clase sobre la cual quiere
aplicar el refactoring:

[[file:screenshots/ino/select_ivar.png]]

Ésta funcionalidad es provista por el ~RefactoringApplier~ como se vió en la
sección \ref{sec:la_interfaz_del_etmo}. Después de elegir la variable de
instancia, si la misma cuenta con algún chequeo por nil, se le provee el
siguiente formulario para que pueda especificar los parámetros del refactoring:

[[file:screenshots/ino/ino_form.png]]

Éste es una instancia de ~IntroduceNullObjectForm~ que comparte todos los
elementos comunes con ~ExtractToMethodObjectForm~, los cuales fueron explicados
en la sección \ref{sec:extract_to_method_object_form}. La sección superior del
formulario, /Null Object Hierarchy/, permite ingresar las clases de la jerarquía
del Null Object. El resto del formulario permite visualizar todos los chequeos
por nil y para cada uno especificar los keywords y los nombres de los
parámetros:

- La lista de chequeos por nil: es una ~PluggableListMorph~ que utiliza como
  model un ~IfNilMessageListModel~ inicializado con todos los ~IfNilCheck~
  encontrados.

- El área de texto con el código del método: debajo del listado hay un área de
  texto que muestra el código del método del ~IfNilCheck~ con el código
  correspondiente al ~IfNilCheck~ seleccionado. Esta visualización busca darle
  mayor contexto al usuario.
  
- La tabla de keywords y nombres de parámetros: esta sección es una
  ~MessageKeywordsAndParametersTable~, que fue explicada en el item
  \ref{itm:message_keywords_and_parameters_table}. Debajo de la misma está la
  preview del message header en un ~PreviewTextModelMorph~, como se vió en el
  item \ref{itm:preview_text_model_morph}.

Todos los modelos de los campos son creados y contenidos por una instancia de
~IntroduceNullObjectRequest~. Ésta es utilizada por el applier para instanciar
el refactoring cuando el usuario hace /Submit/ del formulario.


* Preservación del comportamiento

Todo el compartamiento descripto del ~IntroduceNullObject~ tiene tests
automáticos que lo cubren. Además, ya es parte de Cuis University y los
estudiantes de la cátedra de Ingeniería del Software I lo están utilizando en la
materia.
